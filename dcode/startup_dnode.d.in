
|======================== startup_dnode.d ================================

| Contains procedures for:
|  - inspection of objects
|  - object/text interconversion
|  - transcription of objects
|  - file <=> VM interchange
|  - module support
|  - emulators of dvt operators

/toconsole_ ~toconsole def
save /startup_common_save name 
/startup_common_buf vmstatus sub 10 div /b array def
startup_common_save capsave {
  getstartupdir (startup_common.d) startup_common_buf readfile mkact exec
  getstartupdir (startup_libs.d) startup_common_buf readfile mkact exec
} stopped startup_common_save restore {
  1024 /b array 0 
  (Unable to load: ) fax
  getstartupdir fax (startup_common.d\n) fax
  0 exch getinterval toconsole
  stop
} if

/dm_type /dnode def

|============================= userdict =================================

|----------------- myname
| -- | (hostname)
| just allocate it on startup
/myname getmyname def

|---------------- socketdead
| socket | --
| default handler just throws away the socket and signals an error

| socket aborted | -- <<error thrown>>
/socketmsg 1024 /b array def
/socketdead {
  true 3 -1 roll
  userdict /mpidata known not {pop} {
    mpidata /socket known not {pop} {
      mpidata begin {
        socket eq a_ (\n) toconsole {
          socketmsg 0 {/red} mkpass {
            (On ) fax myname fax ( port ) fax * getmyport * number (: ) fax
            (** rthreads socket dead\n) fax
          } color_text 0 exch getinterval toconsole
          kill
          pop false
        } if
      } stopped end {stop} if
    } ifelse
  } ifelse {
    myname getmyport (socketdead) ERRORS /DEAD_SOCKET get 
    socketmsg errormessage toconsole
  } if ~abort if
} bind def

@ENABLE_RTHREADS_START@
/mpidata 200 dict dup begin | [
  /cpawn -1 def
  /pawns 0 def
  /memsize <x 100000 200 200 1000 200> def

  /winmade false def
  /pbuf 80 /b array def
  /mpiinfo [] def
  /precall {} def
  /postcall {} def
  
  /updatet {
    winmade {{currentdict begin drawwindow} stopped pop} {
      pbuf 0 (pawn ) fax * cpawn * number (:\n) fax 0 exch getinterval
      toconsole_
    } ifelse
  } bind def

  /checkbusy {
    dup * eq {
      pop
      false pawnbusy {or} forall {(Pawn is busy!\n) toconsole_ stop} if
    } {
      pawnbusy exch get {(Pawn is busy!\n) toconsole_ stop} if
    } ifelse
  } bind def

  /makebusy {
    dup checkbusy
    dup * eq {pop 0 1 pawns 1 sub {true pawnbusy 3 -1 roll put} for} {
      true pawnbusy 3 -1 roll put
    } ifelse
    updatet
  } bind def

  /makeready {
    dup * eq {pop 0 1 pawns 1 sub {false pawnbusy 3 -1 roll put} for} {
      false pawnbusy 3 -1 roll put
    } ifelse
    updatet
  } bind def

  | save rank (name) | --
  /sethostname {
    2 index capsave 
    255 /b array 0 * 4 index * number (: ) fax 3 -1 roll fax
    0 exch getinterval
    nodenames 3 -1 roll 1 add put
    end
    restore
  } bind def

  /makeready_dpawn {
    {makeready} stopped end {stop} if restore
  } bind def

  /setcurrent {/cpawn name
    updatet
  } bind def

  /kill {
    {null makerthreads postcall} stopped
    {winmade ~deletewin if} stopped pop
    currentdict /save_ known {save_ restore} if
    -1 setcurrent
    /pawns 0 def
    {stop} if
  } bind def 

  Xwindows_ {
    /NORMALFONT {fontdict /NORMALFONT get} bind def
    /BOLDFONT {fontdict /BOLDFONT get} bind def
    
    /windowsize {
      { [ 3 1 roll | ]
        winmade not {stop} if
        wH ne exch wW ne or {
          wid wW wH resizewindow
        } if 
      } stopped end {cleartomark stop} if pop
    } bind def

    /drawwindow {
      { [ | ]
        winmade not {stop} if
        wid woutline BLACK drawline
        0 1 mpidata /pawns get 1 add 1 sub {drawnode} for
      } stopped end {cleartomark stop} if pop
    } bind def

    /drawnode {/kpawn name
      wid noderects kpawn get
      kpawn 0 eq ~BG {
        pawnbusy kpawn 1 sub get ~HBG ~BG ifelse
      } ifelse fillrectangle

      wid 
      nodelocs kpawn get exec      
      nodenames kpawn get
      cpawn dup * eq kpawn 0 ne and exch kpawn 1 sub eq or 
      ~HIGHTEXT ~NORMALTEXT ifelse
      drawtext pop pop pop
    } bind def

    /actions 3 dict dup begin | [
      /click {kpawn 1 sub setcurrent} bind def
      /cancel {* makeready} bind def
      /group {* setcurrent} bind def |]
    end def

    /mouseclick {
      { [ 4 1 roll | ]
        winmade not {stop} if
        /mS name /mY name /mX name
        /kpawn mY 1 sub 13 div def
        mS /default actions mouseaction pop
      } stopped end {cleartomark stop} if pop
    } bind def

    /newwin {
      {[ | ]
        Xwindows not {stop} if

        /BLACK <d 0 0 0>       mapcolor def
        /GRAY  <d 0.2 0.2 0.2> mapcolor def
        /BLUE  <d 0 0 1>       mapcolor def
        /RED   <d 1 0 0>       mapcolor def
        /LBLUE <d 0.1 0.1 0.9> mapcolor def
        
        /BG <d 235 243 248>  dup length /d array copy 255 div mapcolor def
        /HBG <d 166 219 160> dup length /d array copy 255 div mapcolor def
    
        /NORMALTEXT ~NORMALFONT [null BLACK -1 0] makefont def
        /HIGHTEXT ~BOLDFONT [null BLUE -1 0] makefont def
    
        screensize /scrH name /scrW name
        
        /wW 200 2 add def
        /wH mpidata /pawns get 1 add 13 mul 2 add def
        
        /woutline [ 0 0 wW 1 sub 0 wW 1 sub wH 1 sub 0 wH 1 sub 0 0 ] def
        
        /noderects [
          /x 1 def
          1 13 mpidata /pawns get 1 add 1 sub 13 mul 1 add { /y name
            /r 4 /w array def
            x r 0 put  y r 1 put wW 2 sub r 2 put 13 r 3 put
            r
          } for
        ] def

        /nodelocs [
          /x 5 def
          12 13 mpidata /pawns get 1 add 1 sub 13 mul 12 add { /y name
            ~[x y 6 sub]
          } for
        ] def

        /nodenames [
          255 /b array 0 dvtnodeid fax (:) fax * getmyport * number 
          0 exch getinterval

          /i 0 def
          0 2 mpiinfo length 1 sub {/j name
            mpiinfo j get {
              255 /b array 0 * i * number (: ) fax
              mpiinfo j 1 add get dup /host known {/host get fax} {pop} ifelse
              0 exch getinterval
              /i i 1 add def
            } repeat
          } for
        ] def

        /wid [scrW wW sub 10 sub scrH wH sub 10 sub wW wH ]
          (ThePawns) (Pawns) makewindow 
        def
        /winnamebuf 30 /b array def
        /winname 
          winnamebuf 0 (/w) fax * wid * number 0 exch getinterval mkact exec 
        def
        currentdict userdict winname put
        wid true mapwindow
        /winmade true def
        BG pop
      } stopped {cleartomark stop} if pop
    } bind def
    
    /deletewin {
      {[ |]
        /winmade false def
        wid deletewindow
      } stopped {cleartomark stop} if pop
    } bind def

    /delete_window {{deletewin} stopped end {stop} if} bind def
  } if

  | [[n /key val ...]...] | --
  /rthreads_multi_ {
    [exch {
      dup 0 get 1 index length 1 sub 2 div dict dup begin | [n /k v] n dict 
      3 -1 roll 1 1 index length 1 sub getinterval  | n dict [/k v..]
      0 2 2 index length 1 sub { | n dict [/k v..] i
        2 copy get 3 1 roll      | n dict /k [/k v..] i
        2 copy 1 add get         | n dict /k [/k v..] i v 
        3 1 roll pop 3 1 roll    | n dict [/k v..] /k v 
        def                      | n dict [/k v..]
      } for pop end
    } forall] /mpiinfo name
  } bind def


  | [n1 (host1) n2 (host2)... ] | --
  /rthreads_hosts_ {
    [exch
      0 2 2 index length 1 sub {
        [
          2 index 2 index get
          3 index 3 index 1 add get
          1 dict exch 1 index /host put
        ] 3 1 roll pop
      } for pop
    ] rthreads_multi_
  } bind def

  | n | --
  /rthreads_single_ {
    [exch 0 dict] /mpiinfo name
  } bind def

  | ~info-dict-setup | --
  /rthreads_start {
    {
      pawns 0 gt {(** Rthreads already exist!\n) toconsole_ halt} if
      save /save_ name {
        exec
        0 0 2 mpiinfo length 1 sub {mpiinfo exch get add} for /pawns name
        /pawnbusy [pawns {true} repeat] def
        precall
        mpiinfo makerthreads /socket name
        -1 setcurrent
        currentdict /newwin known ~newwin if
        
        socket ~[memsize {exch pop vmresize} ~lock] send
        socket {
          {
            exch not {abort} if
            /fbuf vmstatus sub 10 div /b array def
            ~[~[
              mpirank 
              (hostname) fromsystem dup length 1 sub 0 exch getinterval
              ~mpidata ~begin ~sethostname
            ] ~lock]
            1 index capsave
            getstartupdir (startup_dpawn.d) fbuf readfile mkact exec
            rsend dnoderespond
            restore
          } lock
        } send
        save_ capsave
      } stopped {kill stop} if
    } lock
  } bind def 

  | save pawn# | --
  /notify {
    {
      makeready
      /nwait nwait 1 sub def
      continue
      restore
    } lock
  } bind def |]
end def

/rthread_ops {
  /memsize mpidata get 1 put
} bind def

/rthreads_dicts {
  /memsize mpidata get 2 put
} bind def

/rthreads_execs {
  /memsize mpidata get 3 put
} bind def

/rthread_memory {
  /memsize mpidata get 4 put
} bind def

/rthreads_user {
  /memsize mpidata get 5 put
} bind def

| [[n /key val ..]...] | --
/rthreads_multi {
  mpidata begin {
    ~rthreads_multi_ rthreads_start
  } stopped end {stop} if
} bind def

| n | --
/rthreads_single {
  mpidata begin {
    ~rthreads_single_ rthreads_start
  } stopped end {stop} if
} bind def

| [n1 (host1) n2 (host2)...]
/rthreads_hosts {
  mpidata begin {
    ~rthreads_hosts_ rthreads_start
  } stopped end {stop} if
} bind def
@ENABLE_RTHREADS_END@

| active | ??
| executes active on dnode if mpi hasn't been setup
|   or no rthread active (cpawn == -1)
| if all rthreads active (cpawn == *), executes on all rthreads,
|  otherwise executes on the chosen rthread (cpawn)
/rthreads_exec {unlock} bind def | Overridden immediately if ENABLE_RTHREADS
@ENABLE_RTHREADS_START@
/rthreads_exec {
  mpidata /cpawn get dup -1 eq {pop unlock} {
    mpidata begin {
      dup makebusy
      save exch ~[~[5 -1 roll ~dnodereceive] ~lock] rsend restore
    } stopped end {stop} if
  } ifelse
} bind def

| -- | --
/rthreads_stop {
  mpidata begin {
    checkrthreads not {(** Rthreads not running!\n) toconsole_} if
    pawns 0 eq {(** No rthreads to stop! Halting\n) toconsole_ halt} if
    * checkbusy
    kill
  } stopped end {stop} if
} bind def

| ~func-maker: <<i | {}>> | --
/execpawns {
  {
    mpidata begin {
      save
      0 1 pawns 1 sub {
        dup makebusy
        dup 3 index exec 
        dup null eq {pop pop} {
          ~[exch destruct_exec ~wait_dnode] rsend
        } ifelse
      } for
      restore
      pop

      /nwait pawns def
      {
        nwait 0 eq {exit} if
        halt
      } loop
    } stopped end {stop} if
  } lock
} bind def

| {} | --
/sexecpawns {
  mpidata /cfunc put
  {pop /cfunc find} execpawns
} bind def

| /modulename | --
/module_send {
  mpidata begin /module_send_ layer {
    ~[userdict 3 -1 roll get ~recv_module] /module_cmd name
    {pop /module_cmd find} execpawns
  } stopped /module_send_ _layer end {stop} if
} bind def

@ENABLE_RTHREADS_END@

|============================= command line interface for dvt =====

| dvt... expect to be locked when called

|  ~exec save knode | ??
/dvtreceive_base {
  userdict /knode put
  dup capsave userdict /dvtsave put
  ~rthreads_exec stopped pop
  userdict /dvtsave get restore
  dvtrespond
} bind def

/dvtrespond {
  save
  console ~[userdict /knode get {dvt begin setready_dnode} ~exec] send 
  restore
} bind def

| save (line) knode | ??
/dvtreceive {
  exch mkact 3 1 roll dvtreceive_base
} bind def

| save (line) knode | ??
/dvtsystem {
  ~tosystem 4 -1 roll 3 -1 roll dvtreceive_base
} bind def

/linebuf 8192 /b array def
/dvtexecsystem {
  {
    {linebuf 0 3 -1 roll mkact exec 0 exch getinterval tosystem}
    4 -1 roll 3 -1 roll 
    dvtreceive_base
  } lock
} bind def

|----------------------- color loader and setup
| [/color_name ...] | -- <<redefines toconsole>>
/make_toconsole {
  userdict /color known not {
    getstartupdir (/color.d) fromfiles
  } if
  color /make_toconsole get exec
  whoami
} bind def

| mousestate /wintype actiondict | -- <<action exec'd>> 
/mouseaction {/actiondict name
  | bottom 8 bits are the modifier keys, bottom 8 of top 16 is mouse button
  | Why? No clear reason.
  exch dup -16 bitshift /mB name 255 and /mM name   | /wintype
  mousedict 1 index get /ignore get mM and /mM name | /wintype
  false mousedict 3 -1 roll get {| false /event {}
    1 index /ignore eq {pop pop} {
      actiondict 2 index known not {pop pop} {
        exec {exch pop true exit} {pop} ifelse
      } ifelse
    } ifelse
  } forall
  {actiondict exch get exec true} {false} ifelse
} bind def

| (base-dir) (file) | --
/convert_from_32 {
  save /cstate name {
    /filename name
    /dirname name
    
    /boxfile
      filename length 4 add /b array 0 filename fax (.box) fax pop
    def
    /olddirname
      dirname length 5 add /b array 0 dirname fax (/old/) fax pop
    def
    /newdirname
      dirname length 1 add /b array 0 dirname fax (/) fax pop
    def

    olddirname boxfile readf32 newdirname boxfile writeboxfile
  } stopped cstate restore {stop} if
} bind def

| (base-dir) | --
/convertdir_from_32 {
  save /cdstate name {
    dup length 1 add /b array 0 3 -1 roll fax (/) fax pop /basedirname name
    basedirname length 4 add /b array 0 basedirname fax (old/) fax pop
    /oldbasedirname name
    
    oldbasedirname findfiles {
      0 get (.box$) regex not {pop} {pop /basefilename name pop pop
        (Converting: ) toconsole
        basedirname toconsole basefilename toconsole (\n) toconsole
        basedirname basefilename convert_from_32
        (Done\n) toconsole
      } ifelse
    } forall
  } stopped cdstate restore {stop} if
} bind def

|------------------------------------------------ whoami
| prints name and port
| for use with make_toconsole to identify who looks like who
| -- | -- <<printout>>
|
/whoami ~[
  1024 /b array {
    0 
    myname fax
    (:) fax
    * getmyport * number
    (\n) fax
    0 exch getinterval toconsole_
  } ~exec
] bind def

Xwindows_ {
  /take_input_focus {
    {[
      console dup null eq {pop} {
        {Xwindows {userdict begin take_input_focus} if restore} send
      } ifelse |]
    } stopped cleartomark
    end
  } bind def

  /delete_window {end} bind def | default delete action is nothing.
} if

(Using startup_dnode.d $Id$ V@PACKAGE_VERSION@\n) toconsole
  
getstartupdir (matrix.d) fromfiles

save /tsave name 1024 /b array /tbuf name tsave capsave
tbuf 0 (Trying ) fax getconfdir fax (dnode.d...\n) fax 
0 exch getinterval toconsole
getconfdir (dnode.d) fromxfiles {
  tbuf 0 (Read ) fax getconfdir fax (dnode.d\n) fax 
  0 exch getinterval toconsole
} if
(Trying ~/.dnode ...\n) toconsole
gethomedir (.dnode) fromxfiles {(Read ~/.dnode\n) toconsole_} if |]
@ENABLE_PETSC_START@
tbuf 0 (Trying ) fax getstartupdir fax (petsc.d...\n) fax
0 exch getinterval toconsole
getstartupdir (petsc.d) fromxfiles {
  tbuf 0 (Read ) fax getstartupdir fax (petsc.d\n) fax
  0 exch getinterval toconsole
} if
@ENABLE_PETSC_END@
tsave restore


