(require 'd-mode)
(require 'server)
(require 'comint)

(defgroup d-comint-mode nil "Major mode for DVT shell"
  :prefix "d-comint-mode-"
  :group 'd-mode)

(defcustom d-comint-mode-server t
  "Startup server for emacs when starting dvt"
  :type '(boolean)
  :group 'd-comint-mode)

(defcustom d-comint-mode-keep-focus t 
  "If true, tell dvt to return input focus to dvt buffer in emacs"
  :type '(boolean)
  :group 'd-comint-mode)

(defcustom d-comint-mode-window-size 10
  "Number of lines for popped up dvt window"
  :type '(integer)
  :group 'd-comint-mode)

(defvar explicit-dvt-file-name nil "dvt program name")
(defvar comint-last-output-start)

(defun d-comint-mode-freeze-overlay (overlay is-after begin end &optional len)
  "Prevent OVERLAY from being extended.
This function can be used for the `modification-hooks' overlay
property."
  ;; if stuff was inserted at the end of the overlay
  (when (and is-after
	     (= 0 len)
	     (= end (overlay-end overlay)))
    ;; reset the end of the overlay
    (move-overlay overlay (overlay-start overlay) begin)))

(make-face 'd-comint-mode-highlight-output "Face for d-comint-output")
(copy-face 'font-lock-type-face 'd-comint-mode-highlight-output)
(set-face-foreground 'd-comint-mode-highlight-output "black")

(defun d-comint-mode-prefilter (s)
  (put-text-property 0 (1- (length s)) 'font-lock-face 'comint-highlight-output s)
  s)
 
;; (defun d-comint-mode-filter (s)
;;   (let ((start-marker (or comint-last-output-start (point-min-marker)))
;; 	(end-marker (process-mark (get-buffer-process (current-buffer)))))
;;     (save-excursion
;;       (goto-char start-marker)
;;       (let ((overlay (make-overlay start-marker end-marker)))
;; 	(overlay-put overlay 
;; 	  'modification-hooks '(d-comint-mode-freeze-overlay))
;; 	(overlay-put overlay
;; 	  'face 'd-comint-mode-highlight-output))
;; ;;      (put-text-property (1- end-marker) end-marker 'face 'comint-highlight-input)
;; )))

;;       (set-extent-face make-extent
;;   (let* ((start-marker (or comint-last-output-start (point-min-marker)))
;; 	 (end-marker (1- (process-mark (get-buffer-process (current-buffer)))))
;; 	 (overlay (make-overlay start-marker end-marker)))
;;     (save-excursion
;;       (goto-char start-marker)
;;       (overlay-put overlay 'modification-hooks '(d-comint-mode-freeze-overlay))
;;       (overlay-put overlay 'face 'd-comint-mode-highlight-output)
;;       (put-text-property end-marker (1+ end-marker) 
;; 	'face 'comint-highlight-input)
;; )))

(defvar d-comint-mode-redirect-ignore nil)
(defvar d-comint-mode-redirect-process nil)
(defvar d-comint-mode-redirect-mode)
(defun d-comint-mode-redirect (string)
  (if (or (not d-comint-mode-redirect-mode) d-comint-mode-redirect-ignore)
      string
    (process-send-string d-comint-mode-redirect-process string) ""))

;;;###autoload
(define-derived-mode d-comint-mode comint-mode "DVT"
  "Major mode for handling d-machine"
  (if d-comint-mode-server (server-start))
  (setq comint-prompt-regexp "^")
  (setq comint-input-ring-file-name "~/.dvt_history")

  (require 'd-mode)
  (d-mode-shared)
  (ansi-color-for-comint-mode-on)
  (make-local-variable 'd-comint-mode-redirect-process)
  (make-local-variable 'd-comint-mode-redirect-ignore)

  (set-face-foreground 'comint-highlight-input "blue")
  (make-face-unbold 'comint-highlight-input)
  
;;  (add-hook 'comint-output-filter-functions 'd-comint-mode-filter)
  (add-hook 'comint-preoutput-filter-functions 'd-comint-mode-prefilter)
  (add-hook 'comint-preoutput-filter-functions 'd-comint-mode-redirect)
)

(defun d-comint-mode-send (&rest strings)
  (insert (mapconcat (lambda (s) s) strings ""))
  (comint-send-input))

(defun d-comint-mode-dabort ()
  (interactive)
  (d-comint-mode-send 
   "{ "
   (save-excursion
     (buffer-substring-no-properties
      (line-beginning-position 0)
      (line-end-position 0)))
   " } debug_aborted"))

(defun d-comint-mode-stop ()
  (interactive)
  (goto-char (point-max))
  (delete-region (line-beginning-position) (line-end-position))
  (d-comint-mode-send "! stop")
  (d-comint-mode-scream 0))

(defun d-comint-mode-abort ()
  (interactive)
  (goto-char (point-max))
  (delete-region (line-beginning-position) (line-end-position))
  (d-comint-mode-send "! abort")
  (d-comint-mode-scream 0))

(defun d-comint-mode-continue ()
  (interactive)
  (goto-char (point-max))
  (delete-region (line-beginning-position) (line-end-position))
  (d-comint-mode-send "! continue")
  (d-comint-mode-scream 0))

(defun d-comint-mode-scream-and-send ()
  (interactive)
  (save-excursion
    (beginning-of-line)
    (when (not (eq (char-after) ?\!))
      (insert "! ")))
  (comint-send-input))

(define-minor-mode d-comint-mode-scream "" nil " !"
  '(("" . d-comint-mode-scream-and-send)))

(defun d-comint-mode-redirect-kill-process ()
  (process-send-string d-comint-mode-redirect-process "\n")
  (process-send-eof d-comint-mode-redirect-process)
  (kill-process d-comint-mode-redirect-process)
  (setq d-comint-mode-redirect-process nil))

(defvar d-comint-mode-redirect-command 
  "{ echo 'New process: '; echo \"$(date)\" ; echo '-------------' ; exec cat ; } >> ")

(defun d-comint-mode-redirect-process-open ()
  (let ((d-comint-mode-redirect-ignore t)
	(string1 (concat "[31m"
	 (if d-comint-mode-redirect-mode 
	     (concat "*** Emacs: Redirecting output from dvt terminal to file "
		     (buffer-name) " ***")
	   (concat "*** Emacs: Redirecting output from file " (buffer-name)
		   " to dvt terminal ***"))
	"[0m\n")))
    (comint-output-filter (get-buffer-process (current-buffer)) string1))

  (when (and d-comint-mode-redirect-mode (not d-comint-mode-redirect-process))
    (setq d-comint-mode-redirect-process
	  (start-process (concat (buffer-name) "-redirect") nil
	    "/bin/bash" "-c" (concat d-comint-mode-redirect-command 
				     "\'" (buffer-name) "\'")))
		(set-process-query-on-exit-flag d-comint-mode-redirect-process nil)
    ;;(process-kill-without-query d-comint-mode-redirect-process)
    (add-hook 'kill-buffer-hook 'd-comint-mode-redirect-kill-process
	      nil t))

  (process-send-string d-comint-mode-redirect-process
   (if d-comint-mode-redirect-mode "--- Start ---" "--- Stop ---"))
)

(define-minor-mode d-comint-mode-redirect-mode "" nil " >"
  '() (d-comint-mode-redirect-process-open))

(defun d-comint-mode-invert ()
  (interactive)
  (d-comint-mode-send
   (save-excursion
     (buffer-substring-no-properties
      (line-beginning-position 0)
      (line-end-position 0)))))

(defun d-comint-mode-clear ()
  (interactive)
  (delete-region 1 (point)))

(defvar d-comint-mode-window (* 80 50 5) "")

(defun d-comint-mode-narrow ()
  (interactive)
  (narrow-to-region 
   (let 
       ((d-comint-mode-window-start (- (point-max) d-comint-mode-window)))
     (if (> d-comint-mode-window-start 0) d-comint-mode-window-start 0))
   (point-max)))

(defun d-comint-mode-widen () (interactive) (widen))

(defvar d-comint-mode-map-setup nil "")
(defun d-comint-mode-setup-map ()
  (interactive)
  (setq d-comint-mode-map-setup t)
  (define-key d-comint-mode-map [f1] 'd-comint-mode-invert)
  (define-key d-comint-mode-map [f2] 'd-comint-mode-continue)
  (define-key d-comint-mode-map [f3] 'd-comint-mode-stop)
  (define-key d-comint-mode-map [f4] 'd-comint-mode-abort)
  (define-key d-comint-mode-map [f5] 'd-comint-mode-raise-thehorses)
  (define-key d-comint-mode-map [f6] 'd-comint-mode-raise-all)
  (define-key d-comint-mode-map [(shift f6)] 'd-comint-mode-hide-all)
  (define-key d-comint-mode-map [f7] 'd-comint-mode-focus-raise)
  (define-key d-comint-mode-map [f8] 'd-comint-mode-dnode)
  (define-key d-comint-mode-map [(control !)] 'd-comint-mode-scream)
  (define-key d-comint-mode-map [?\C-1] 'd-comint-mode-scream)
  ;;(define-key d-comint-mode-map [?\C-c ?\C-c] 'd-comint-mode-clear)
  (define-key d-comint-mode-map [?\C-c ?c] 'd-comint-mode-clear)
  (define-key d-comint-mode-map [?\C-c ?\C-a] 'd-comint-mode-dabort)
  (define-key d-comint-mode-map [(control >)] 'd-comint-mode-redirect-mode)
  (define-key d-comint-mode-map [?\C-c ?\C-n] 'd-comint-mode-narrow)
  (define-key d-comint-mode-map [?\C-c ?\C-w] 'd-comint-mode-widen)
)
(if (not d-comint-mode-map-setup) (d-comint-mode-setup-map))

(defun dvt (&optional buffer)
  "Run an inferior shell, with I/O through BUFFER (which defaults to `*shell*').
Interactively, a prefix arg means to prompt for BUFFER.
If BUFFER exists but shell process is not running, make new shell.
If BUFFER exists and shell process is running, just switch to BUFFER.
Program used comes from variable `explicit-shell-file-name',
 or (if that is nil) from the ESHELL environment variable,
 or else from SHELL if there is no ESHELL.
If a file `~/.emacs_SHELLNAME' exists, it is given as initial input
 (Note that this may lose due to a timing error if the shell
  discards input when it starts up.)
The buffer is put in Shell mode, giving commands for sending input
and controlling the subjobs of the shell.  See `shell-mode'.
See also the variable `shell-prompt-pattern'.

To specify a coding system for converting non-ASCII characters
in the input and output to the shell, use \\[universal-coding-system-argument]
before \\[shell].  You can also specify this with \\[set-buffer-process-coding-system]
in the shell buffer, after you start the shell.
The default comes from `process-coding-system-alist' and
`default-process-coding-system'.

The shell file name (sans directories) is used to make a symbol name
such as `explicit-csh-args'.  If that symbol is a variable,
its value is used as a list of arguments when invoking the shell.
Otherwise, one argument `-i' is passed to the shell.

\(Type \\[describe-mode] in the shell buffer for a list of commands.)"
  (interactive
   (list
    (and current-prefix-arg (read-buffer "DVT buffer name: " "*dvt*"))))
  (when (null buffer) (setq buffer "*dvt*"))
  (if (not (comint-check-proc buffer))
      (let* ((prog (or explicit-dvt-file-name
		       (getenv "EDVT")
		       (getenv "DVT")
		       "@bindir@/dvt"))
	     (name (file-name-nondirectory prog))
	     (dir (file-name-directory prog))
	     (startfile (concat "~/.emacs_" name))
	     (xargs-name 'dvt-args)
	     (cdir default-directory)
	     dvt-buffer)
		(save-excursion
		  (set-buffer
		   (setq dvt-buffer 
				 (apply 'make-comint-in-buffer "dvt" buffer prog
						(when (file-exists-p startfile) startfile)
						(when (and xargs-name (boundp xargs-name))
						  (symbol-value xargs-name)))))
		  (d-comint-mode)
		  (when d-comint-mode-server
			(process-send-string 
			 (get-buffer-process dvt-buffer)
			 (concat 
			  "Xwindows {(" (d-comint-mode-shell-quote server-name) ") ("
			  (d-comint-mode-shell-quote (buffer-name dvt-buffer)) 
			  ") take_input_setup} if\n"))))
		(switch-to-buffer dvt-buffer))
    (switch-to-buffer buffer)))

(defun d-comint-mode-quote (string)
  "Quote a string to be sent to and interpreted by the dvt.
This would apply to the body of a string between ( and ).
Parens and backslashes are quoted"
  (interactive "s")
  (let ((start 1))
	(while (string-match "[()\\\\]" string start)
	  (setq start (1+ (match-end 0)))
	  (setq string (replace-match "\\\\\\&" t nil string)))
	string))

(defun d-comint-mode-shell-quote (string)
  "Quote a string which will be used by the dvt as a word in a shell command.
This quotes per \\[shell-quote-argument], then requotes per \\[d-comint-mode-quote]"
  (interactive "s")
  (d-comint-mode-quote (shell-quote-argument string)))

(defun d-comint-mode-focus (buffer-name)
  "Set input focus to dvt buffer. 
Used by dvt to signal to emacs that it should re-take focus."
  (when d-comint-mode-keep-focus
	(let ((old-windows (get-buffer-window-list buffer-name)))
	  (pop-to-buffer buffer-name)
	  (unless (catch 'find-window
				(dolist (old-window old-windows)
				  (when (eq old-window (selected-window))
					(throw 'find-window t))))
		(shrink-window (- (window-height) d-comint-mode-window-size))))
	(if (eq window-system 'x)
		(x-focus-frame nil))))

(defun d-comint-mode-focus-raise (&optional buffer-name)
  "Set input focus to dvt buffer, and raise frame in X.
Used by dvt to signal to emacs that it should pop up and take focus"
  (interactive
   (list (and current-prefix-arg (read-buffer "DVT buffer: " "*dvt*"))))
  (when (null buffer-name) (setq buffer-name "*dvt*"))
  (d-comint-mode-focus (buffer-name))
  (make-frame-visible)
  (raise-frame (selected-frame)))

(defun d-comint-mode-raise-thehorses ()
  "Tell dvt to raise TheHorses window."
  (interactive)
  (process-send-string 
   (get-buffer-process (current-buffer))
   "* userdict begin raise_thehorses\n"))

(defun d-comint-mode-raise-all ()
  "Tell dvt to raise all dvt windows"
  (interactive)
  (process-send-string
   (get-buffer-process (current-buffer))
   "* userdict begin raise_all\n"))

(defun d-comint-mode-hide-all ()
  "Tell dvt to hide all dvt windows"
  (interactive)
  (process-send-string
   (get-buffer-process (current-buffer))
   "* userdict begin hide_all\n"))

(define-minor-mode d-comint-mode-dnode-mode 
  "Bind f8 to d-comint-mode-dnode in a dnode shell buffer." 
  nil " dnode" '(([f8] . d-comint-mode-dnode)))

(defun d-comint-mode-dnode (port &optional buffer-pre)
  (interactive 
   (list
	(read-number "Port number: ")
	(and current-prefix-arg (read-buffer "Dnode buffer prefix: " "*dnode*"))))
  (when (null buffer-pre) (setq buffer-pre "*dnode*"))
  
  (let* ((buffer-name (concat buffer-pre (format "<%d>" port)))
		 (old-windows (get-buffer-window-list buffer-name)))
	(if (not (null d-comint-mode-dnode-mode))
		(switch-to-buffer buffer-name)
	  (pop-to-buffer buffer-name)
	  (unless (catch 'find-window
				(dolist (old-window old-windows)
				  (when (eq old-window (selected-window))
					(throw 'find-window t))))
		(shrink-window (- (window-height) d-comint-mode-window-size))))
	(shell buffer-name)
	(when (null d-comint-mode-dnode-mode) 
	  (d-comint-mode-dnode-mode)
	  (goto-char (point-max))
	  (insert (format "dnode %d" port)) 
	  (comint-send-input)
	  (add-hook 
	   'comint-exec-hook 
	   (lambda () (insert (format "dnode %d" port)) (comint-send-input))
	   nil t))))

(require 'ansi-color)
(provide 'd-comint-mode)

