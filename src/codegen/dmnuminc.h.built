

static void DBencode(D t, B *dp)
{
*((B *)dp) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
static void DWencode(D t, B *dp)
{
*((W *)dp) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
static void DLencode(D t, B *dp)
{
*((L *)dp) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
static void DSencode(D t, B *dp)
{
*((S *)dp) = t;
}
static void DDencode(D t, B *dp)
{
*((D *)dp) = t;
}
typedef void (*ENCODEfct)(D,B*);
static ENCODEfct ENCODElist[] = {
DBencode, 
DWencode, 
DLencode, 
DSencode, 
DDencode, 
};

static L BLvalue(B *sp)
{
D t; L tc;
if ((t = *((B *)sp)) == BINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L WLvalue(B *sp)
{
D t; L tc;
if ((t = *((W *)sp)) == WINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L LLvalue(B *sp)
{
D t; L tc;
if ((t = *((L *)sp)) == LINF) t = DINF;
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L SLvalue(B *sp)
{
D t; L tc;
t = *((S *)sp);
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
static L DLvalue(B *sp)
{
D t; L tc;
t = *((D *)sp);
*((L *)&tc) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
return(tc);
}
typedef L (*VALUEfct)(B*);
static VALUEfct VALUElist[] = {
BLvalue, 
WLvalue, 
LLvalue, 
SLvalue, 
DLvalue, 
};

static D BDtest(B *sp)
{
D t;
if ((t = *((B *)sp)) == BINF) t = DINF;
return(t);
}
static D WDtest(B *sp)
{
D t;
if ((t = *((W *)sp)) == WINF) t = DINF;
return(t);
}
static D LDtest(B *sp)
{
D t;
if ((t = *((L *)sp)) == LINF) t = DINF;
return(t);
}
static D SDtest(B *sp)
{
D t;
t = *((S *)sp);
return(t);
}
static D DDtest(B *sp)
{
D t;
t = *((D *)sp);
return(t);
}
typedef D (*TESTfct)(B*);
static TESTfct TESTlist[] = {
BDtest, 
WDtest, 
LDtest, 
SDtest, 
DDtest, 
};

static void BBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
    return OK;
  }

  static void BBmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    BBmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BBmoveSAc(sf, df);
#if ENABLE_THREADS
    else BBmoveSAc(sf,df);
#endif 
  }

static void BBmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void BBmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; B * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; B * d;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L BBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void BBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void BBmoveAA(B *sf, B *df)
   {
    if (serialized) BBmoveAAs(sf,df);
#if ENABLE_THREADS
    else BBmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else BBmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void BWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void BWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L BWmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
    return OK;
  }

  static void BWmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    BWmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BWmoveSAc(sf, df);
#if ENABLE_THREADS
    else BWmoveSAc(sf,df);
#endif 
  }

static void BWmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void BWmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; W * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void BWmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; W * d;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L BWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void BWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void BWmoveAA(B *sf, B *df)
   {
    if (serialized) BWmoveAAs(sf,df);
#if ENABLE_THREADS
    else BWmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else BWmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void BLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void BLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L BLmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
    return OK;
  }

  static void BLmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    BLmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BLmoveSAc(sf, df);
#if ENABLE_THREADS
    else BLmoveSAc(sf,df);
#endif 
  }

static void BLmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void BLmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; L * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void BLmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; L * d;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L BLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void BLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void BLmoveAA(B *sf, B *df)
   {
    if (serialized) BLmoveAAs(sf,df);
#if ENABLE_THREADS
    else BLmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else BLmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void BSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

  static void BSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L BSmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = data->in;
}
    return OK;
  }

  static void BSmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    BSmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BSmoveSAc(sf, df);
#if ENABLE_THREADS
    else BSmoveSAc(sf,df);
#endif 
  }

static void BSmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void BSmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; S * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
    }

    static void BSmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; S * d;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L BSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((S *)d++) = t;
}
       return OK;
    }

    static void BSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void BSmoveAA(B *sf, B *df)
   {
    if (serialized) BSmoveAAs(sf,df);
#if ENABLE_THREADS
    else BSmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else BSmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void BDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

  static void BDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((t = *((B *)NUM_VAL(sf))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L BDmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = data->in;
}
    return OK;
  }

  static void BDmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    BDmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((B *)NUM_VAL(sf))) == BINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BDmoveSAc(sf, df);
#if ENABLE_THREADS
    else BDmoveSAc(sf,df);
#endif 
  }

static void BDmoveAS(B *sf, B *df)
{
D t; B *s; 
s = (B *)VALUE_BASE(sf);

if ((t = *((B *)s)) == BINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void BDmoveAAp(B *sf, B *df)
    {
      D t; L n; B * restrict s; D * restrict d;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
    }

    static void BDmoveAAs(B *sf, B *df)
    {
       D t; L n; B * s; D * d;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L BDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; B * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((B *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)s++)) == BINF) t = DINF;
*((D *)d++) = t;
}
       return OK;
    }

    static void BDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        BDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void BDmoveAA(B *sf, B *df)
   {
    if (serialized) BDmoveAAs(sf,df);
#if ENABLE_THREADS
    else BDmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else BDmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void WBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void WBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L WBmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
    return OK;
  }

  static void WBmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    WBmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WBmoveSAc(sf, df);
#if ENABLE_THREADS
    else WBmoveSAc(sf,df);
#endif 
  }

static void WBmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void WBmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; B * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void WBmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; B * d;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L WBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void WBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void WBmoveAA(B *sf, B *df)
   {
    if (serialized) WBmoveAAs(sf,df);
#if ENABLE_THREADS
    else WBmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else WBmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void WWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
    return OK;
  }

  static void WWmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    WWmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WWmoveSAc(sf, df);
#if ENABLE_THREADS
    else WWmoveSAc(sf,df);
#endif 
  }

static void WWmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void WWmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; W * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; W * d;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L WWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void WWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void WWmoveAA(B *sf, B *df)
   {
    if (serialized) WWmoveAAs(sf,df);
#if ENABLE_THREADS
    else WWmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else WWmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void WLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void WLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L WLmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
    return OK;
  }

  static void WLmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    WLmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WLmoveSAc(sf, df);
#if ENABLE_THREADS
    else WLmoveSAc(sf,df);
#endif 
  }

static void WLmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void WLmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; L * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void WLmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; L * d;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L WLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void WLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void WLmoveAA(B *sf, B *df)
   {
    if (serialized) WLmoveAAs(sf,df);
#if ENABLE_THREADS
    else WLmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else WLmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void WSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

  static void WSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L WSmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = data->in;
}
    return OK;
  }

  static void WSmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    WSmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WSmoveSAc(sf, df);
#if ENABLE_THREADS
    else WSmoveSAc(sf,df);
#endif 
  }

static void WSmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void WSmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; S * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
    }

    static void WSmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; S * d;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L WSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((S *)d++) = t;
}
       return OK;
    }

    static void WSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void WSmoveAA(B *sf, B *df)
   {
    if (serialized) WSmoveAAs(sf,df);
#if ENABLE_THREADS
    else WSmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else WSmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void WDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

  static void WDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((t = *((W *)NUM_VAL(sf))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L WDmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = data->in;
}
    return OK;
  }

  static void WDmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    WDmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((W *)NUM_VAL(sf))) == WINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WDmoveSAc(sf, df);
#if ENABLE_THREADS
    else WDmoveSAc(sf,df);
#endif 
  }

static void WDmoveAS(B *sf, B *df)
{
D t; W *s; 
s = (W *)VALUE_BASE(sf);

if ((t = *((W *)s)) == WINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void WDmoveAAp(B *sf, B *df)
    {
      D t; L n; W * restrict s; D * restrict d;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
    }

    static void WDmoveAAs(B *sf, B *df)
    {
       D t; L n; W * s; D * d;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L WDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; W * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((W *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)s++)) == WINF) t = DINF;
*((D *)d++) = t;
}
       return OK;
    }

    static void WDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        WDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void WDmoveAA(B *sf, B *df)
   {
    if (serialized) WDmoveAAs(sf,df);
#if ENABLE_THREADS
    else WDmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else WDmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void LBmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void LBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L LBmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
    return OK;
  }

  static void LBmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    LBmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LBmoveSAc(sf, df);
#if ENABLE_THREADS
    else LBmoveSAc(sf,df);
#endif 
  }

static void LBmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void LBmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; B * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void LBmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; B * d;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L LBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void LBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void LBmoveAA(B *sf, B *df)
   {
    if (serialized) LBmoveAAs(sf,df);
#if ENABLE_THREADS
    else LBmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else LBmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void LWmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void LWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L LWmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
    return OK;
  }

  static void LWmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    LWmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LWmoveSAc(sf, df);
#if ENABLE_THREADS
    else LWmoveSAc(sf,df);
#endif 
  }

static void LWmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void LWmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; W * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void LWmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; W * d;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L LWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void LWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void LWmoveAA(B *sf, B *df)
   {
    if (serialized) LWmoveAAs(sf,df);
#if ENABLE_THREADS
    else LWmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else LWmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void LLmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
    return OK;
  }

  static void LLmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    LLmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LLmoveSAc(sf, df);
#if ENABLE_THREADS
    else LLmoveSAc(sf,df);
#endif 
  }

static void LLmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void LLmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; L * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; L * d;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L LLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void LLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void LLmoveAA(B *sf, B *df)
   {
    if (serialized) LLmoveAAs(sf,df);
#if ENABLE_THREADS
    else LLmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else LLmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void LSmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((S *)NUM_VAL(df)) = t;
}

  static void LSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L LSmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = data->in;
}
    return OK;
  }

  static void LSmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    LSmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LSmoveSAc(sf, df);
#if ENABLE_THREADS
    else LSmoveSAc(sf,df);
#endif 
  }

static void LSmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((S *)NUM_VAL(df)) = t;
}

    static void LSmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; S * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
    }

    static void LSmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; S * d;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L LSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((S *)d++) = t;
}
       return OK;
    }

    static void LSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void LSmoveAA(B *sf, B *df)
   {
    if (serialized) LSmoveAAs(sf,df);
#if ENABLE_THREADS
    else LSmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else LSmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void LDmoveSS(B *sf, B *df)
{
D t;
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
*((D *)NUM_VAL(df)) = t;
}

  static void LDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((t = *((L *)NUM_VAL(sf))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L LDmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = data->in;
}
    return OK;
  }

  static void LDmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    LDmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
if ((data.in = *((L *)NUM_VAL(sf))) == LINF) data.in = DINF;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LDmoveSAc(sf, df);
#if ENABLE_THREADS
    else LDmoveSAc(sf,df);
#endif 
  }

static void LDmoveAS(B *sf, B *df)
{
D t; L *s; 
s = (L *)VALUE_BASE(sf);

if ((t = *((L *)s)) == LINF) t = DINF;

*((D *)NUM_VAL(df)) = t;
}

    static void LDmoveAAp(B *sf, B *df)
    {
      D t; L n; L * restrict s; D * restrict d;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
    }

    static void LDmoveAAs(B *sf, B *df)
    {
       D t; L n; L * s; D * d;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L LDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; L * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((L *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)s++)) == LINF) t = DINF;
*((D *)d++) = t;
}
       return OK;
    }

    static void LDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        LDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void LDmoveAA(B *sf, B *df)
   {
    if (serialized) LDmoveAAs(sf,df);
#if ENABLE_THREADS
    else LDmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else LDmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void SBmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void SBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L SBmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
    return OK;
  }

  static void SBmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    SBmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((S *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SBmoveSAc(sf, df);
#if ENABLE_THREADS
    else SBmoveSAc(sf,df);
#endif 
  }

static void SBmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void SBmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; B * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void SBmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; B * d;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L SBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void SBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void SBmoveAA(B *sf, B *df)
   {
    if (serialized) SBmoveAAs(sf,df);
#if ENABLE_THREADS
    else SBmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else SBmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void SWmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void SWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L SWmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
    return OK;
  }

  static void SWmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    SWmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((S *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SWmoveSAc(sf, df);
#if ENABLE_THREADS
    else SWmoveSAc(sf,df);
#endif 
  }

static void SWmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void SWmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; W * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void SWmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; W * d;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L SWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void SWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void SWmoveAA(B *sf, B *df)
   {
    if (serialized) SWmoveAAs(sf,df);
#if ENABLE_THREADS
    else SWmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else SWmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void SLmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void SLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L SLmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
    return OK;
  }

  static void SLmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    SLmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((S *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SLmoveSAc(sf, df);
#if ENABLE_THREADS
    else SLmoveSAc(sf,df);
#endif 
  }

static void SLmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void SLmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; L * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void SLmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; L * d;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L SLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void SLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void SLmoveAA(B *sf, B *df)
   {
    if (serialized) SLmoveAAs(sf,df);
#if ENABLE_THREADS
    else SLmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else SLmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void SSmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

  static void SSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = data->in;
}
    return OK;
  }

  static void SSmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    SSmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((S *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SSmoveSAc(sf, df);
#if ENABLE_THREADS
    else SSmoveSAc(sf,df);
#endif 
  }

static void SSmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void SSmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; S * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
    }

    static void SSmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; S * d;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
t = *((S *)s++);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((S *)d++) = t;
}
       return OK;
    }

    static void SSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void SSmoveAA(B *sf, B *df)
   {
    if (serialized) SSmoveAAs(sf,df);
#if ENABLE_THREADS
    else SSmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else SSmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void SDmoveSS(B *sf, B *df)
{
D t;
t = *((S *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

  static void SDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
t = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = data->in;
}
    return OK;
  }

  static void SDmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    SDmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((S *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SDmoveSAc(sf, df);
#if ENABLE_THREADS
    else SDmoveSAc(sf,df);
#endif 
  }

static void SDmoveAS(B *sf, B *df)
{
D t; S *s; 
s = (S *)VALUE_BASE(sf);

t = *((S *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void SDmoveAAp(B *sf, B *df)
    {
      D t; L n; S * restrict s; D * restrict d;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
    }

    static void SDmoveAAs(B *sf, B *df)
    {
       D t; L n; S * s; D * d;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L SDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; S * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((S *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
t = *((S *)s++);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)s++);
*((D *)d++) = t;
}
       return OK;
    }

    static void SDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        SDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void SDmoveAA(B *sf, B *df)
   {
    if (serialized) SDmoveAAs(sf,df);
#if ENABLE_THREADS
    else SDmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else SDmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void DBmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void DBmoveSAs(B *sf, B *df)
  {
    D t; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L DBmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((B *)d++) = (((data->in) > BMAX) || ((-data->in) < -BMAX) || (data->in == DINF))? BINF : data->in;
}
    return OK;
  }

  static void DBmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    DBmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((D *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DBmoveSAc(sf, df);
#if ENABLE_THREADS
    else DBmoveSAc(sf,df);
#endif 
  }

static void DBmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

    static void DBmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; B * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void DBmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; B * d;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#if ENABLE_THREADS
    static L DBmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; B * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
       return OK;
    }

    static void DBmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DBmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void DBmoveAA(B *sf, B *df)
   {
    if (serialized) DBmoveAAs(sf,df);
#if ENABLE_THREADS
    else DBmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else DBmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void DWmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void DWmoveSAs(B *sf, B *df)
  {
    D t; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L DWmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((W *)d++) = (((data->in) > WMAX) || ((-data->in) < -WMAX) || (data->in == DINF))? WINF : data->in;
}
    return OK;
  }

  static void DWmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    DWmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((D *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DWmoveSAc(sf, df);
#if ENABLE_THREADS
    else DWmoveSAc(sf,df);
#endif 
  }

static void DWmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

    static void DWmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; W * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void DWmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; W * d;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#if ENABLE_THREADS
    static L DWmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; W * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
       return OK;
    }

    static void DWmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DWmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void DWmoveAA(B *sf, B *df)
   {
    if (serialized) DWmoveAAs(sf,df);
#if ENABLE_THREADS
    else DWmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else DWmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void DLmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void DLmoveSAs(B *sf, B *df)
  {
    D t; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L DLmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((L *)d++) = (((data->in) > LMAX) || ((-data->in) < -LMAX) || (data->in == DINF))? LINF : data->in;
}
    return OK;
  }

  static void DLmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    DLmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((D *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DLmoveSAc(sf, df);
#if ENABLE_THREADS
    else DLmoveSAc(sf,df);
#endif 
  }

static void DLmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

    static void DLmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; L * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void DLmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; L * d;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#if ENABLE_THREADS
    static L DLmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; L * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
       return OK;
    }

    static void DLmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DLmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void DLmoveAA(B *sf, B *df)
   {
    if (serialized) DLmoveAAs(sf,df);
#if ENABLE_THREADS
    else DLmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else DLmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void DSmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((S *)NUM_VAL(df)) = t;
}

  static void DSmoveSAs(B *sf, B *df)
  {
    D t; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
*((S *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((S *)d++) = data->in;
}
    return OK;
  }

  static void DSmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    DSmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((D *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DSmoveSAc(sf, df);
#if ENABLE_THREADS
    else DSmoveSAc(sf,df);
#endif 
  }

static void DSmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((S *)NUM_VAL(df)) = t;
}

    static void DSmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; S * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
    }

    static void DSmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; S * d;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DSmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; S * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
t = *((D *)s++);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((S *)d++) = t;
}
       return OK;
    }

    static void DSmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DSmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void DSmoveAA(B *sf, B *df)
   {
    if (serialized) DSmoveAAs(sf,df);
#if ENABLE_THREADS
    else DSmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else DSmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

static void DDmoveSS(B *sf, B *df)
{
D t;
t = *((D *)NUM_VAL(sf));
*((D *)NUM_VAL(df)) = t;
}

  static void DDmoveSAs(B *sf, B *df)
  {
    D t; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
t = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDmoveSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
*((D *)d++) = data->in;
}
for (n = (n_ & 7); n>0; n--) {
*((D *)d++) = data->in;
}
    return OK;
  }

  static void DDmoveSAc(B* sf, B* df)
  {
    UL nways; thread_array_data data; D t;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
    DDmoveSAs(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
data.in = *((D *)NUM_VAL(sf));
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDmoveSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDmoveSA(B* sf, B* df)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DDmoveSAc(sf, df);
#if ENABLE_THREADS
    else DDmoveSAc(sf,df);
#endif 
  }

static void DDmoveAS(B *sf, B *df)
{
D t; D *s; 
s = (D *)VALUE_BASE(sf);

t = *((D *)s);

*((D *)NUM_VAL(df)) = t;
}

    static void DDmoveAAp(B *sf, B *df)
    {
      D t; L n; D * restrict s; D * restrict d;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
    }

    static void DDmoveAAs(B *sf, B *df)
    {
       D t; L n; D * s; D * d;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
    }


#if ENABLE_THREADS
    static L DDmoveAAt(UL id, B* indata)
    {
       thread_array_data* data = (thread_array_data*) indata;
       D t; L n, n_; D * restrict s; D * restrict d;
       n_ = data->perthread;
       if (thread_max == id) n_ += data->leftover;
       s = ((D *) data->sf_start)+data->perthread*id;
       d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
t = *((D *)s++);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)s++);
*((D *)d++) = t;
}
       return OK;
    }

    static void DDmoveAAc(B *sf, B *df)
    {
      UL nways; thread_array_data data;
      if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
        DDmoveAAp(sf, df);
    else {
      nways = ARRAY_SIZE(df) /(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDmoveAAt, (B*) &data);
     }
   }
#endif //ENABLE_THREADS

   static void DDmoveAA(B *sf, B *df)
   {
    if (serialized) DDmoveAAs(sf,df);
#if ENABLE_THREADS
    else DDmoveAAc(sf, df);
#else //!ENABLE_THREADS
    else DDmoveAAp(sf,df);
#endif //!ENABLE_THREADS
   }

typedef void (*MOVEfct)(B*,B*);
static MOVEfct MOVElist[] = {
BBmoveSS, BBmoveSA, BBmoveAS, BBmoveAA, 
BWmoveSS, BWmoveSA, BWmoveAS, BWmoveAA, 
BLmoveSS, BLmoveSA, BLmoveAS, BLmoveAA, 
BSmoveSS, BSmoveSA, BSmoveAS, BSmoveAA, 
BDmoveSS, BDmoveSA, BDmoveAS, BDmoveAA, 
WBmoveSS, WBmoveSA, WBmoveAS, WBmoveAA, 
WWmoveSS, WWmoveSA, WWmoveAS, WWmoveAA, 
WLmoveSS, WLmoveSA, WLmoveAS, WLmoveAA, 
WSmoveSS, WSmoveSA, WSmoveAS, WSmoveAA, 
WDmoveSS, WDmoveSA, WDmoveAS, WDmoveAA, 
LBmoveSS, LBmoveSA, LBmoveAS, LBmoveAA, 
LWmoveSS, LWmoveSA, LWmoveAS, LWmoveAA, 
LLmoveSS, LLmoveSA, LLmoveAS, LLmoveAA, 
LSmoveSS, LSmoveSA, LSmoveAS, LSmoveAA, 
LDmoveSS, LDmoveSA, LDmoveAS, LDmoveAA, 
SBmoveSS, SBmoveSA, SBmoveAS, SBmoveAA, 
SWmoveSS, SWmoveSA, SWmoveAS, SWmoveAA, 
SLmoveSS, SLmoveSA, SLmoveAS, SLmoveAA, 
SSmoveSS, SSmoveSA, SSmoveAS, SSmoveAA, 
SDmoveSS, SDmoveSA, SDmoveAS, SDmoveAA, 
DBmoveSS, DBmoveSA, DBmoveAS, DBmoveAA, 
DWmoveSS, DWmoveSA, DWmoveAS, DWmoveAA, 
DLmoveSS, DLmoveSA, DLmoveAS, DLmoveAA, 
DSmoveSS, DSmoveSA, DSmoveAS, DSmoveAA, 
DDmoveSS, DDmoveSA, DDmoveAS, DDmoveAA, 

};

static void BBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BBdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BBdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BBdyADDASs(df, sf);
#if ENABLE_THREADS
    else BBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BBdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BBdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BBdyADDSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BBdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BBdyADDAA(B * df, B * sf)
    {
      if (serialized) BBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BBdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else BBdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BBdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BBdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BBdySUBASs(df, sf);
#if ENABLE_THREADS
    else BBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BBdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BBdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BBdySUBSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BBdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BBdySUBAA(B * df, B * sf)
    {
      if (serialized) BBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BBdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else BBdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BBdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BBdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BBdyMULASs(df, sf);
#if ENABLE_THREADS
    else BBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BBdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BBdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BBdyMULSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BBdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BBdyMULAA(B * df, B * sf)
    {
      if (serialized) BBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BBdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else BBdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BBdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BBdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BBdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BBdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BBdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BBdyDIVSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BBdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BBdyDIVAA(B * df, B * sf)
    {
      if (serialized) BBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BBdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else BBdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BBdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BBdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BBdyPWRSA(B* df, B *sf)
  {
    BBdyPWRSAs(df, sf);
  }

    static void BBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BBdyPWRAA(B * df, B * sf)
    {
      if (serialized) BBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BBdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else BBdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BBdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BBdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BBdyMODASs(df, sf);
#if ENABLE_THREADS
    else BBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BBdyMODSA(B* df, B *sf)
  {
    BBdyMODSAs(df, sf);
  }

    static void BBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BBdyMODAA(B * df, B * sf)
    {
      if (serialized) BBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BBdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else BBdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BBdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BBdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BBdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BBdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BBdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BBdyTHEARCSA(B* df, B *sf)
  {
    BBdyTHEARCSAs(df, sf);
  }

    static void BBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; B * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; B * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BBdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else BBdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BWdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BWdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BWdyADDASs(df, sf);
#if ENABLE_THREADS
    else BWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BWdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BWdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BWdyADDSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BWdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BWdyADDAA(B * df, B * sf)
    {
      if (serialized) BWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BWdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else BWdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BWdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BWdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BWdySUBASs(df, sf);
#if ENABLE_THREADS
    else BWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BWdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BWdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BWdySUBSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BWdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BWdySUBAA(B * df, B * sf)
    {
      if (serialized) BWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BWdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else BWdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BWdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BWdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BWdyMULASs(df, sf);
#if ENABLE_THREADS
    else BWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BWdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BWdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BWdyMULSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BWdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BWdyMULAA(B * df, B * sf)
    {
      if (serialized) BWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BWdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else BWdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BWdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BWdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BWdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BWdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BWdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BWdyDIVSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BWdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BWdyDIVAA(B * df, B * sf)
    {
      if (serialized) BWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BWdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else BWdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BWdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BWdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BWdyPWRSA(B* df, B *sf)
  {
    BWdyPWRSAs(df, sf);
  }

    static void BWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BWdyPWRAA(B * df, B * sf)
    {
      if (serialized) BWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BWdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else BWdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BWdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BWdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BWdyMODASs(df, sf);
#if ENABLE_THREADS
    else BWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BWdyMODSA(B* df, B *sf)
  {
    BWdyMODSAs(df, sf);
  }

    static void BWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BWdyMODAA(B * df, B * sf)
    {
      if (serialized) BWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BWdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else BWdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BWdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BWdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BWdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BWdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BWdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BWdyTHEARCSA(B* df, B *sf)
  {
    BWdyTHEARCSAs(df, sf);
  }

    static void BWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; B * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; B * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BWdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else BWdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BLdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BLdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BLdyADDASs(df, sf);
#if ENABLE_THREADS
    else BLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BLdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BLdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BLdyADDSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BLdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BLdyADDAA(B * df, B * sf)
    {
      if (serialized) BLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BLdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else BLdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BLdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BLdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BLdySUBASs(df, sf);
#if ENABLE_THREADS
    else BLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BLdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BLdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BLdySUBSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BLdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BLdySUBAA(B * df, B * sf)
    {
      if (serialized) BLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BLdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else BLdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BLdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BLdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BLdyMULASs(df, sf);
#if ENABLE_THREADS
    else BLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BLdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BLdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BLdyMULSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BLdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BLdyMULAA(B * df, B * sf)
    {
      if (serialized) BLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BLdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else BLdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BLdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BLdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BLdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BLdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BLdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BLdyDIVSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BLdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BLdyDIVAA(B * df, B * sf)
    {
      if (serialized) BLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BLdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else BLdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BLdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BLdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BLdyPWRSA(B* df, B *sf)
  {
    BLdyPWRSAs(df, sf);
  }

    static void BLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BLdyPWRAA(B * df, B * sf)
    {
      if (serialized) BLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BLdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else BLdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BLdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BLdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BLdyMODASs(df, sf);
#if ENABLE_THREADS
    else BLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BLdyMODSA(B* df, B *sf)
  {
    BLdyMODSAs(df, sf);
  }

    static void BLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BLdyMODAA(B * df, B * sf)
    {
      if (serialized) BLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BLdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else BLdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BLdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BLdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BLdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BLdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BLdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BLdyTHEARCSA(B* df, B *sf)
  {
    BLdyTHEARCSAs(df, sf);
  }

    static void BLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; B * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; B * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BLdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else BLdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BSdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BSdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BSdyADDASs(df, sf);
#if ENABLE_THREADS
    else BSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BSdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BSdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BSdyADDSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BSdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BSdyADDAA(B * df, B * sf)
    {
      if (serialized) BSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BSdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else BSdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BSdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BSdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BSdySUBASs(df, sf);
#if ENABLE_THREADS
    else BSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BSdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BSdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BSdySUBSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BSdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BSdySUBAA(B * df, B * sf)
    {
      if (serialized) BSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BSdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else BSdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BSdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BSdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BSdyMULASs(df, sf);
#if ENABLE_THREADS
    else BSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BSdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BSdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BSdyMULSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BSdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BSdyMULAA(B * df, B * sf)
    {
      if (serialized) BSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BSdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else BSdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BSdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BSdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BSdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BSdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BSdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BSdyDIVSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BSdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BSdyDIVAA(B * df, B * sf)
    {
      if (serialized) BSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BSdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else BSdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BSdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BSdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BSdyPWRSA(B* df, B *sf)
  {
    BSdyPWRSAs(df, sf);
  }

    static void BSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BSdyPWRAA(B * df, B * sf)
    {
      if (serialized) BSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BSdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else BSdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BSdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BSdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BSdyMODASs(df, sf);
#if ENABLE_THREADS
    else BSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BSdyMODSA(B* df, B *sf)
  {
    BSdyMODSAs(df, sf);
  }

    static void BSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BSdyMODAA(B * df, B * sf)
    {
      if (serialized) BSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BSdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else BSdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BSdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BSdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BSdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BSdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BSdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BSdyTHEARCSA(B* df, B *sf)
  {
    BSdyTHEARCSAs(df, sf);
  }

    static void BSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; B * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; B * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BSdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else BSdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BDdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BDdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BDdyADDASs(df, sf);
#if ENABLE_THREADS
    else BDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BDdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BDdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BDdyADDSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BDdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else BDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t += tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BDdyADDAA(B * df, B * sf)
    {
      if (serialized) BDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else BDdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else BDdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BDdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BDdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BDdySUBASs(df, sf);
#if ENABLE_THREADS
    else BDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BDdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BDdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BDdySUBSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t += tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BDdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else BDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t -= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BDdySUBAA(B * df, B * sf)
    {
      if (serialized) BDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else BDdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else BDdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BDdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BDdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BDdyMULASs(df, sf);
#if ENABLE_THREADS
    else BDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BDdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BDdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BDdyMULSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BDdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else BDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t *= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BDdyMULAA(B * df, B * sf)
    {
      if (serialized) BDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else BDdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else BDdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BDdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BDdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else BDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

#if ENABLE_THREADS
 static L BDdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void BDdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      BDdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, BDdyDIVSAt, (B*) &data);
      
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void BDdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      BDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else BDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void BDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t /= tt;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BDdyDIVAA(B * df, B * sf)
    {
      if (serialized) BDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else BDdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else BDdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BDdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BDdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else BDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BDdyPWRSA(B* df, B *sf)
  {
    BDdyPWRSAs(df, sf);
  }

    static void BDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = pow(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BDdyPWRAA(B * df, B * sf)
    {
      if (serialized) BDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else BDdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else BDdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BDdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BDdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BDdyMODASs(df, sf);
#if ENABLE_THREADS
    else BDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BDdyMODSA(B* df, B *sf)
  {
    BDdyMODSAs(df, sf);
  }

    static void BDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = fmod(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BDdyMODAA(B * df, B * sf)
    {
      if (serialized) BDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else BDdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else BDdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void BDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

  static void BDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict d;
    d = (B *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
  }

#if ENABLE_THREADS
  static L BDdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; B * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }

  static void BDdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BDdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BDdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BDdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    BDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else BDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void BDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
   }

  static void BDdyTHEARCSA(B* df, B *sf)
  {
    BDdyTHEARCSAs(df, sf);
  }

    static void BDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; B * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }

    static void BDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; B * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L BDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; B * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((B *)d)) == BINF) t = DINF;
t = thearc(t,tt);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
      return OK;
    }

    static void BDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          BDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, BDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void BDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) BDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else BDdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else BDdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WBdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WBdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WBdyADDASs(df, sf);
#if ENABLE_THREADS
    else WBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WBdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WBdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WBdyADDSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WBdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WBdyADDAA(B * df, B * sf)
    {
      if (serialized) WBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WBdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else WBdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WBdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WBdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WBdySUBASs(df, sf);
#if ENABLE_THREADS
    else WBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WBdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WBdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WBdySUBSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WBdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WBdySUBAA(B * df, B * sf)
    {
      if (serialized) WBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WBdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else WBdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WBdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WBdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WBdyMULASs(df, sf);
#if ENABLE_THREADS
    else WBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WBdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WBdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WBdyMULSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WBdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WBdyMULAA(B * df, B * sf)
    {
      if (serialized) WBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WBdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else WBdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WBdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WBdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WBdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WBdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WBdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WBdyDIVSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WBdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WBdyDIVAA(B * df, B * sf)
    {
      if (serialized) WBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WBdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else WBdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WBdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WBdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WBdyPWRSA(B* df, B *sf)
  {
    WBdyPWRSAs(df, sf);
  }

    static void WBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WBdyPWRAA(B * df, B * sf)
    {
      if (serialized) WBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WBdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else WBdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WBdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WBdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WBdyMODASs(df, sf);
#if ENABLE_THREADS
    else WBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WBdyMODSA(B* df, B *sf)
  {
    WBdyMODSAs(df, sf);
  }

    static void WBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WBdyMODAA(B * df, B * sf)
    {
      if (serialized) WBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WBdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else WBdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WBdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WBdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WBdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WBdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WBdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WBdyTHEARCSA(B* df, B *sf)
  {
    WBdyTHEARCSAs(df, sf);
  }

    static void WBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; W * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; W * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WBdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else WBdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WWdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WWdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WWdyADDASs(df, sf);
#if ENABLE_THREADS
    else WWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WWdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WWdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WWdyADDSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WWdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WWdyADDAA(B * df, B * sf)
    {
      if (serialized) WWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WWdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else WWdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WWdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WWdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WWdySUBASs(df, sf);
#if ENABLE_THREADS
    else WWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WWdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WWdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WWdySUBSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WWdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WWdySUBAA(B * df, B * sf)
    {
      if (serialized) WWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WWdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else WWdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WWdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WWdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WWdyMULASs(df, sf);
#if ENABLE_THREADS
    else WWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WWdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WWdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WWdyMULSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WWdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WWdyMULAA(B * df, B * sf)
    {
      if (serialized) WWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WWdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else WWdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WWdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WWdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WWdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WWdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WWdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WWdyDIVSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WWdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WWdyDIVAA(B * df, B * sf)
    {
      if (serialized) WWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WWdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else WWdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WWdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WWdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WWdyPWRSA(B* df, B *sf)
  {
    WWdyPWRSAs(df, sf);
  }

    static void WWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WWdyPWRAA(B * df, B * sf)
    {
      if (serialized) WWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WWdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else WWdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WWdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WWdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WWdyMODASs(df, sf);
#if ENABLE_THREADS
    else WWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WWdyMODSA(B* df, B *sf)
  {
    WWdyMODSAs(df, sf);
  }

    static void WWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WWdyMODAA(B * df, B * sf)
    {
      if (serialized) WWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WWdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else WWdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WWdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WWdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WWdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WWdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WWdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WWdyTHEARCSA(B* df, B *sf)
  {
    WWdyTHEARCSAs(df, sf);
  }

    static void WWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; W * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; W * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WWdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else WWdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WLdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WLdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WLdyADDASs(df, sf);
#if ENABLE_THREADS
    else WLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WLdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WLdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WLdyADDSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WLdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WLdyADDAA(B * df, B * sf)
    {
      if (serialized) WLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WLdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else WLdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WLdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WLdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WLdySUBASs(df, sf);
#if ENABLE_THREADS
    else WLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WLdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WLdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WLdySUBSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WLdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WLdySUBAA(B * df, B * sf)
    {
      if (serialized) WLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WLdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else WLdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WLdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WLdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WLdyMULASs(df, sf);
#if ENABLE_THREADS
    else WLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WLdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WLdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WLdyMULSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WLdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WLdyMULAA(B * df, B * sf)
    {
      if (serialized) WLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WLdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else WLdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WLdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WLdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WLdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WLdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WLdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WLdyDIVSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WLdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WLdyDIVAA(B * df, B * sf)
    {
      if (serialized) WLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WLdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else WLdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WLdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WLdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WLdyPWRSA(B* df, B *sf)
  {
    WLdyPWRSAs(df, sf);
  }

    static void WLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WLdyPWRAA(B * df, B * sf)
    {
      if (serialized) WLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WLdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else WLdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WLdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WLdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WLdyMODASs(df, sf);
#if ENABLE_THREADS
    else WLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WLdyMODSA(B* df, B *sf)
  {
    WLdyMODSAs(df, sf);
  }

    static void WLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WLdyMODAA(B * df, B * sf)
    {
      if (serialized) WLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WLdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else WLdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WLdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WLdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WLdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WLdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WLdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WLdyTHEARCSA(B* df, B *sf)
  {
    WLdyTHEARCSAs(df, sf);
  }

    static void WLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; W * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; W * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WLdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else WLdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WSdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WSdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WSdyADDASs(df, sf);
#if ENABLE_THREADS
    else WSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WSdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WSdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WSdyADDSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WSdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WSdyADDAA(B * df, B * sf)
    {
      if (serialized) WSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WSdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else WSdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WSdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WSdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WSdySUBASs(df, sf);
#if ENABLE_THREADS
    else WSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WSdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WSdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WSdySUBSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WSdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WSdySUBAA(B * df, B * sf)
    {
      if (serialized) WSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WSdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else WSdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WSdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WSdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WSdyMULASs(df, sf);
#if ENABLE_THREADS
    else WSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WSdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WSdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WSdyMULSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WSdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WSdyMULAA(B * df, B * sf)
    {
      if (serialized) WSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WSdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else WSdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WSdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WSdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WSdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WSdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WSdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WSdyDIVSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WSdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WSdyDIVAA(B * df, B * sf)
    {
      if (serialized) WSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WSdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else WSdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WSdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WSdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WSdyPWRSA(B* df, B *sf)
  {
    WSdyPWRSAs(df, sf);
  }

    static void WSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WSdyPWRAA(B * df, B * sf)
    {
      if (serialized) WSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WSdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else WSdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WSdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WSdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WSdyMODASs(df, sf);
#if ENABLE_THREADS
    else WSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WSdyMODSA(B* df, B *sf)
  {
    WSdyMODSAs(df, sf);
  }

    static void WSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WSdyMODAA(B * df, B * sf)
    {
      if (serialized) WSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WSdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else WSdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WSdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WSdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WSdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WSdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WSdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WSdyTHEARCSA(B* df, B *sf)
  {
    WSdyTHEARCSAs(df, sf);
  }

    static void WSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; W * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; W * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WSdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else WSdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WDdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WDdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WDdyADDASs(df, sf);
#if ENABLE_THREADS
    else WDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WDdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WDdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WDdyADDSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WDdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else WDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t += tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WDdyADDAA(B * df, B * sf)
    {
      if (serialized) WDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else WDdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else WDdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WDdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WDdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WDdySUBASs(df, sf);
#if ENABLE_THREADS
    else WDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WDdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WDdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WDdySUBSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t += tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WDdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else WDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t -= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WDdySUBAA(B * df, B * sf)
    {
      if (serialized) WDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else WDdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else WDdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WDdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WDdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WDdyMULASs(df, sf);
#if ENABLE_THREADS
    else WDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WDdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WDdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WDdyMULSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WDdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else WDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t *= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WDdyMULAA(B * df, B * sf)
    {
      if (serialized) WDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else WDdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else WDdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WDdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WDdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else WDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

#if ENABLE_THREADS
 static L WDdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void WDdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      WDdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, WDdyDIVSAt, (B*) &data);
      
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void WDdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      WDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else WDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void WDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t /= tt;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WDdyDIVAA(B * df, B * sf)
    {
      if (serialized) WDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else WDdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else WDdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WDdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WDdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else WDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WDdyPWRSA(B* df, B *sf)
  {
    WDdyPWRSAs(df, sf);
  }

    static void WDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = pow(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WDdyPWRAA(B * df, B * sf)
    {
      if (serialized) WDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else WDdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else WDdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WDdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WDdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WDdyMODASs(df, sf);
#if ENABLE_THREADS
    else WDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WDdyMODSA(B* df, B *sf)
  {
    WDdyMODSAs(df, sf);
  }

    static void WDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = fmod(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WDdyMODAA(B * df, B * sf)
    {
      if (serialized) WDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else WDdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else WDdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void WDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

  static void WDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict d;
    d = (W *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
  }

#if ENABLE_THREADS
  static L WDdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; W * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }

  static void WDdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WDdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WDdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WDdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    WDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else WDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void WDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
   }

  static void WDdyTHEARCSA(B* df, B *sf)
  {
    WDdyTHEARCSAs(df, sf);
  }

    static void WDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; W * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }

    static void WDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; W * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L WDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; W * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((W *)d)) == WINF) t = DINF;
t = thearc(t,tt);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
      return OK;
    }

    static void WDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          WDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, WDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void WDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) WDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else WDdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else WDdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LBdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LBdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LBdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LBdyADDASs(df, sf);
#if ENABLE_THREADS
    else LBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LBdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LBdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LBdyADDSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LBdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LBdyADDAA(B * df, B * sf)
    {
      if (serialized) LBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LBdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else LBdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LBdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LBdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LBdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LBdySUBASs(df, sf);
#if ENABLE_THREADS
    else LBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LBdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LBdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LBdySUBSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LBdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LBdySUBAA(B * df, B * sf)
    {
      if (serialized) LBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LBdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else LBdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LBdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LBdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LBdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LBdyMULASs(df, sf);
#if ENABLE_THREADS
    else LBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LBdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LBdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LBdyMULSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LBdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LBdyMULAA(B * df, B * sf)
    {
      if (serialized) LBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LBdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else LBdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LBdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LBdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LBdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LBdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LBdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LBdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LBdyDIVSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LBdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LBdyDIVAA(B * df, B * sf)
    {
      if (serialized) LBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LBdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else LBdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LBdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LBdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LBdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LBdyPWRSA(B* df, B *sf)
  {
    LBdyPWRSAs(df, sf);
  }

    static void LBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LBdyPWRAA(B * df, B * sf)
    {
      if (serialized) LBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LBdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else LBdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LBdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LBdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LBdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LBdyMODASs(df, sf);
#if ENABLE_THREADS
    else LBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LBdyMODSA(B* df, B *sf)
  {
    LBdyMODSAs(df, sf);
  }

    static void LBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LBdyMODAA(B * df, B * sf)
    {
      if (serialized) LBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LBdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else LBdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LBdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LBdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LBdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LBdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LBdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LBdyTHEARCSA(B* df, B *sf)
  {
    LBdyTHEARCSAs(df, sf);
  }

    static void LBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; L * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; L * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LBdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else LBdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LWdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LWdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LWdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LWdyADDASs(df, sf);
#if ENABLE_THREADS
    else LWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LWdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LWdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LWdyADDSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LWdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LWdyADDAA(B * df, B * sf)
    {
      if (serialized) LWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LWdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else LWdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LWdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LWdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LWdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LWdySUBASs(df, sf);
#if ENABLE_THREADS
    else LWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LWdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LWdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LWdySUBSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LWdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LWdySUBAA(B * df, B * sf)
    {
      if (serialized) LWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LWdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else LWdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LWdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LWdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LWdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LWdyMULASs(df, sf);
#if ENABLE_THREADS
    else LWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LWdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LWdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LWdyMULSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LWdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LWdyMULAA(B * df, B * sf)
    {
      if (serialized) LWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LWdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else LWdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LWdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LWdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LWdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LWdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LWdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LWdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LWdyDIVSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LWdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LWdyDIVAA(B * df, B * sf)
    {
      if (serialized) LWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LWdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else LWdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LWdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LWdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LWdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LWdyPWRSA(B* df, B *sf)
  {
    LWdyPWRSAs(df, sf);
  }

    static void LWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LWdyPWRAA(B * df, B * sf)
    {
      if (serialized) LWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LWdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else LWdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LWdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LWdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LWdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LWdyMODASs(df, sf);
#if ENABLE_THREADS
    else LWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LWdyMODSA(B* df, B *sf)
  {
    LWdyMODSAs(df, sf);
  }

    static void LWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LWdyMODAA(B * df, B * sf)
    {
      if (serialized) LWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LWdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else LWdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LWdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LWdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LWdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LWdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LWdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LWdyTHEARCSA(B* df, B *sf)
  {
    LWdyTHEARCSAs(df, sf);
  }

    static void LWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; L * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; L * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LWdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else LWdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LLdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LLdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LLdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LLdyADDASs(df, sf);
#if ENABLE_THREADS
    else LLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LLdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LLdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LLdyADDSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LLdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LLdyADDAA(B * df, B * sf)
    {
      if (serialized) LLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LLdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else LLdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LLdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LLdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LLdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LLdySUBASs(df, sf);
#if ENABLE_THREADS
    else LLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LLdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LLdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LLdySUBSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LLdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LLdySUBAA(B * df, B * sf)
    {
      if (serialized) LLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LLdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else LLdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LLdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LLdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LLdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LLdyMULASs(df, sf);
#if ENABLE_THREADS
    else LLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LLdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LLdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LLdyMULSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LLdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LLdyMULAA(B * df, B * sf)
    {
      if (serialized) LLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LLdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else LLdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LLdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LLdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LLdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LLdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LLdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LLdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LLdyDIVSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LLdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LLdyDIVAA(B * df, B * sf)
    {
      if (serialized) LLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LLdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else LLdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LLdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LLdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LLdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LLdyPWRSA(B* df, B *sf)
  {
    LLdyPWRSAs(df, sf);
  }

    static void LLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LLdyPWRAA(B * df, B * sf)
    {
      if (serialized) LLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LLdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else LLdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LLdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LLdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LLdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LLdyMODASs(df, sf);
#if ENABLE_THREADS
    else LLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LLdyMODSA(B* df, B *sf)
  {
    LLdyMODSAs(df, sf);
  }

    static void LLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LLdyMODAA(B * df, B * sf)
    {
      if (serialized) LLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LLdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else LLdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LLdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LLdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LLdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LLdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LLdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LLdyTHEARCSA(B* df, B *sf)
  {
    LLdyTHEARCSAs(df, sf);
  }

    static void LLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; L * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; L * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LLdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else LLdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LSdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LSdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LSdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LSdyADDASs(df, sf);
#if ENABLE_THREADS
    else LSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LSdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LSdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LSdyADDSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LSdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LSdyADDAA(B * df, B * sf)
    {
      if (serialized) LSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LSdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else LSdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LSdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LSdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LSdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LSdySUBASs(df, sf);
#if ENABLE_THREADS
    else LSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LSdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LSdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LSdySUBSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LSdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LSdySUBAA(B * df, B * sf)
    {
      if (serialized) LSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LSdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else LSdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LSdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LSdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LSdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LSdyMULASs(df, sf);
#if ENABLE_THREADS
    else LSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LSdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LSdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LSdyMULSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LSdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LSdyMULAA(B * df, B * sf)
    {
      if (serialized) LSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LSdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else LSdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LSdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LSdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LSdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LSdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LSdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LSdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LSdyDIVSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LSdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LSdyDIVAA(B * df, B * sf)
    {
      if (serialized) LSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LSdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else LSdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LSdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LSdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LSdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LSdyPWRSA(B* df, B *sf)
  {
    LSdyPWRSAs(df, sf);
  }

    static void LSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LSdyPWRAA(B * df, B * sf)
    {
      if (serialized) LSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LSdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else LSdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LSdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LSdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LSdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LSdyMODASs(df, sf);
#if ENABLE_THREADS
    else LSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LSdyMODSA(B* df, B *sf)
  {
    LSdyMODSAs(df, sf);
  }

    static void LSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LSdyMODAA(B * df, B * sf)
    {
      if (serialized) LSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LSdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else LSdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LSdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LSdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LSdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LSdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LSdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LSdyTHEARCSA(B* df, B *sf)
  {
    LSdyTHEARCSAs(df, sf);
  }

    static void LSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; L * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; L * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LSdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else LSdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LDdyADDSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LDdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LDdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LDdyADDASs(df, sf);
#if ENABLE_THREADS
    else LDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LDdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LDdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LDdyADDSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LDdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else LDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t += tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LDdyADDAA(B * df, B * sf)
    {
      if (serialized) LDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else LDdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else LDdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LDdySUBSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LDdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LDdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LDdySUBASs(df, sf);
#if ENABLE_THREADS
    else LDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LDdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LDdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LDdySUBSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t += tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LDdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else LDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t -= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LDdySUBAA(B * df, B * sf)
    {
      if (serialized) LDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else LDdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else LDdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LDdyMULSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LDdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LDdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LDdyMULASs(df, sf);
#if ENABLE_THREADS
    else LDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LDdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LDdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LDdyMULSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LDdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else LDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t *= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LDdyMULAA(B * df, B * sf)
    {
      if (serialized) LDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else LDdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else LDdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LDdyDIVSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LDdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LDdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else LDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

#if ENABLE_THREADS
 static L LDdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void LDdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      LDdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, LDdyDIVSAt, (B*) &data);
      
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
      tt = data.out;
      
t *= tt;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
    }
  }
#endif //ENABLE_THREADS

  static void LDdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      LDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else LDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void LDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t /= tt;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LDdyDIVAA(B * df, B * sf)
    {
      if (serialized) LDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else LDdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else LDdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LDdyPWRSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LDdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LDdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else LDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LDdyPWRSA(B* df, B *sf)
  {
    LDdyPWRSAs(df, sf);
  }

    static void LDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = pow(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LDdyPWRAA(B * df, B * sf)
    {
      if (serialized) LDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else LDdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else LDdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LDdyMODSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LDdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LDdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LDdyMODASs(df, sf);
#if ENABLE_THREADS
    else LDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LDdyMODSA(B* df, B *sf)
  {
    LDdyMODSAs(df, sf);
  }

    static void LDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = fmod(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LDdyMODAA(B * df, B * sf)
    {
      if (serialized) LDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else LDdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else LDdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void LDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

  static void LDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict d;
    d = (L *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
  }

#if ENABLE_THREADS
  static L LDdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; L * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }

  static void LDdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LDdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LDdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LDdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    LDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else LDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void LDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
   }

  static void LDdyTHEARCSA(B* df, B *sf)
  {
    LDdyTHEARCSAs(df, sf);
  }

    static void LDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; L * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }

    static void LDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; L * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    }


#ifdef ENABLE_THREADS
    static L LDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; L * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
if ((t = *((L *)d)) == LINF) t = DINF;
t = thearc(t,tt);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
      return OK;
    }

    static void LDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          LDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, LDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void LDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) LDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else LDdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else LDdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SBdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SBdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SBdyADDASs(df, sf);
#if ENABLE_THREADS
    else SBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SBdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SBdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SBdyADDSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SBdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SBdyADDAA(B * df, B * sf)
    {
      if (serialized) SBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SBdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else SBdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SBdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SBdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SBdySUBASs(df, sf);
#if ENABLE_THREADS
    else SBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SBdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SBdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SBdySUBSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SBdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SBdySUBAA(B * df, B * sf)
    {
      if (serialized) SBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SBdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else SBdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SBdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SBdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SBdyMULASs(df, sf);
#if ENABLE_THREADS
    else SBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SBdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SBdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SBdyMULSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SBdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SBdyMULAA(B * df, B * sf)
    {
      if (serialized) SBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SBdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else SBdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SBdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SBdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SBdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SBdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SBdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SBdyDIVSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SBdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SBdyDIVAA(B * df, B * sf)
    {
      if (serialized) SBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SBdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else SBdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SBdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SBdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SBdyPWRSA(B* df, B *sf)
  {
    SBdyPWRSAs(df, sf);
  }

    static void SBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SBdyPWRAA(B * df, B * sf)
    {
      if (serialized) SBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SBdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else SBdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SBdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SBdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SBdyMODASs(df, sf);
#if ENABLE_THREADS
    else SBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SBdyMODSA(B* df, B *sf)
  {
    SBdyMODSAs(df, sf);
  }

    static void SBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SBdyMODAA(B * df, B * sf)
    {
      if (serialized) SBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SBdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else SBdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SBdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SBdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SBdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SBdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SBdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SBdyTHEARCSA(B* df, B *sf)
  {
    SBdyTHEARCSAs(df, sf);
  }

    static void SBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; S * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; S * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SBdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else SBdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SWdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SWdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SWdyADDASs(df, sf);
#if ENABLE_THREADS
    else SWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SWdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SWdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SWdyADDSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SWdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SWdyADDAA(B * df, B * sf)
    {
      if (serialized) SWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SWdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else SWdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SWdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SWdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SWdySUBASs(df, sf);
#if ENABLE_THREADS
    else SWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SWdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SWdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SWdySUBSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SWdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SWdySUBAA(B * df, B * sf)
    {
      if (serialized) SWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SWdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else SWdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SWdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SWdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SWdyMULASs(df, sf);
#if ENABLE_THREADS
    else SWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SWdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SWdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SWdyMULSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SWdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SWdyMULAA(B * df, B * sf)
    {
      if (serialized) SWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SWdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else SWdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SWdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SWdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SWdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SWdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SWdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SWdyDIVSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SWdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SWdyDIVAA(B * df, B * sf)
    {
      if (serialized) SWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SWdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else SWdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SWdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SWdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SWdyPWRSA(B* df, B *sf)
  {
    SWdyPWRSAs(df, sf);
  }

    static void SWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SWdyPWRAA(B * df, B * sf)
    {
      if (serialized) SWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SWdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else SWdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SWdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SWdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SWdyMODASs(df, sf);
#if ENABLE_THREADS
    else SWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SWdyMODSA(B* df, B *sf)
  {
    SWdyMODSAs(df, sf);
  }

    static void SWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SWdyMODAA(B * df, B * sf)
    {
      if (serialized) SWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SWdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else SWdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SWdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SWdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SWdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SWdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SWdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SWdyTHEARCSA(B* df, B *sf)
  {
    SWdyTHEARCSAs(df, sf);
  }

    static void SWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; S * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; S * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SWdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else SWdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SLdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SLdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SLdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SLdyADDASs(df, sf);
#if ENABLE_THREADS
    else SLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SLdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SLdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SLdyADDSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SLdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SLdyADDAA(B * df, B * sf)
    {
      if (serialized) SLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SLdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else SLdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SLdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SLdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SLdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SLdySUBASs(df, sf);
#if ENABLE_THREADS
    else SLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SLdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SLdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SLdySUBSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SLdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SLdySUBAA(B * df, B * sf)
    {
      if (serialized) SLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SLdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else SLdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SLdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SLdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SLdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SLdyMULASs(df, sf);
#if ENABLE_THREADS
    else SLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SLdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SLdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SLdyMULSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SLdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SLdyMULAA(B * df, B * sf)
    {
      if (serialized) SLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SLdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else SLdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SLdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SLdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SLdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SLdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SLdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SLdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SLdyDIVSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SLdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SLdyDIVAA(B * df, B * sf)
    {
      if (serialized) SLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SLdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else SLdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SLdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SLdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SLdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SLdyPWRSA(B* df, B *sf)
  {
    SLdyPWRSAs(df, sf);
  }

    static void SLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SLdyPWRAA(B * df, B * sf)
    {
      if (serialized) SLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SLdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else SLdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SLdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SLdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SLdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SLdyMODASs(df, sf);
#if ENABLE_THREADS
    else SLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SLdyMODSA(B* df, B *sf)
  {
    SLdyMODSAs(df, sf);
  }

    static void SLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SLdyMODAA(B * df, B * sf)
    {
      if (serialized) SLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SLdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else SLdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SLdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SLdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SLdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SLdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SLdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SLdyTHEARCSA(B* df, B *sf)
  {
    SLdyTHEARCSAs(df, sf);
  }

    static void SLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; S * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; S * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SLdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else SLdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SSdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SSdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SSdyADDASs(df, sf);
#if ENABLE_THREADS
    else SSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SSdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SSdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SSdyADDSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SSdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SSdyADDAA(B * df, B * sf)
    {
      if (serialized) SSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SSdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else SSdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SSdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SSdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SSdySUBASs(df, sf);
#if ENABLE_THREADS
    else SSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SSdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SSdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SSdySUBSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SSdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SSdySUBAA(B * df, B * sf)
    {
      if (serialized) SSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SSdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else SSdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SSdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SSdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SSdyMULASs(df, sf);
#if ENABLE_THREADS
    else SSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SSdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SSdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SSdyMULSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SSdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SSdyMULAA(B * df, B * sf)
    {
      if (serialized) SSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SSdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else SSdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SSdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SSdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SSdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SSdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SSdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SSdyDIVSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SSdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SSdyDIVAA(B * df, B * sf)
    {
      if (serialized) SSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SSdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else SSdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SSdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SSdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SSdyPWRSA(B* df, B *sf)
  {
    SSdyPWRSAs(df, sf);
  }

    static void SSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SSdyPWRAA(B * df, B * sf)
    {
      if (serialized) SSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SSdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else SSdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SSdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SSdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SSdyMODASs(df, sf);
#if ENABLE_THREADS
    else SSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SSdyMODSA(B* df, B *sf)
  {
    SSdyMODSAs(df, sf);
  }

    static void SSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SSdyMODAA(B * df, B * sf)
    {
      if (serialized) SSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SSdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else SSdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SSdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SSdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SSdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SSdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SSdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SSdyTHEARCSA(B* df, B *sf)
  {
    SSdyTHEARCSAs(df, sf);
  }

    static void SSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; S * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; S * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SSdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else SSdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SDdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SDdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SDdyADDASs(df, sf);
#if ENABLE_THREADS
    else SDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SDdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SDdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SDdyADDSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SDdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else SDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }

    static void SDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t += tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SDdyADDAA(B * df, B * sf)
    {
      if (serialized) SDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else SDdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else SDdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SDdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SDdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SDdySUBASs(df, sf);
#if ENABLE_THREADS
    else SDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SDdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SDdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SDdySUBSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SDdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else SDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }

    static void SDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t -= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SDdySUBAA(B * df, B * sf)
    {
      if (serialized) SDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else SDdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else SDdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SDdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SDdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SDdyMULASs(df, sf);
#if ENABLE_THREADS
    else SDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SDdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SDdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SDdyMULSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SDdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else SDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }

    static void SDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t *= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SDdyMULAA(B * df, B * sf)
    {
      if (serialized) SDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else SDdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else SDdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    return OK;
  }

  static void SDdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SDdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else SDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((S *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L SDdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void SDdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      SDdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, SDdyDIVSAt, (B*) &data);
      
t = *((S *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((S *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void SDdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      SDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else SDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void SDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }

    static void SDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t /= tt;
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SDdyDIVAA(B * df, B * sf)
    {
      if (serialized) SDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else SDdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else SDdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SDdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SDdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else SDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SDdyPWRSA(B* df, B *sf)
  {
    SDdyPWRSAs(df, sf);
  }

    static void SDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }

    static void SDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = pow(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SDdyPWRAA(B * df, B * sf)
    {
      if (serialized) SDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else SDdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else SDdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SDdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SDdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SDdyMODASs(df, sf);
#if ENABLE_THREADS
    else SDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SDdyMODSA(B* df, B *sf)
  {
    SDdyMODSAs(df, sf);
  }

    static void SDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }

    static void SDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = fmod(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SDdyMODAA(B * df, B * sf)
    {
      if (serialized) SDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else SDdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else SDdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void SDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((S *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((S *)NUM_VAL(df)) = t;
}

  static void SDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict d;
    d = (S *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L SDdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; S * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    return OK;
  }

  static void SDdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SDdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SDdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SDdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    SDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else SDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void SDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((S *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((S *)NUM_VAL(df)) = t;
   }

  static void SDdyTHEARCSA(B* df, B *sf)
  {
    SDdyTHEARCSAs(df, sf);
  }

    static void SDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; S * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }

    static void SDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; S * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L SDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; S * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((S *)d);
t = thearc(t,tt);
*((S *)d++) = t;
}
      return OK;
    }

    static void SDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          SDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, SDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void SDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) SDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else SDdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else SDdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DBdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DBdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DBdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DBdyADDASs(df, sf);
#if ENABLE_THREADS
    else DBdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DBdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DBdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DBdyADDSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DBdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DBdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DBdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyADDAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DBdyADDAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DBdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DBdyADDAA(B * df, B * sf)
    {
      if (serialized) DBdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DBdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else DBdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DBdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DBdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DBdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DBdySUBASs(df, sf);
#if ENABLE_THREADS
    else DBdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DBdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DBdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DBdySUBSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DBdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DBdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DBdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdySUBAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DBdySUBAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DBdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DBdySUBAA(B * df, B * sf)
    {
      if (serialized) DBdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DBdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else DBdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DBdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DBdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DBdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DBdyMULASs(df, sf);
#if ENABLE_THREADS
    else DBdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DBdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DBdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DBdyMULSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DBdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DBdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DBdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyMULAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DBdyMULAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DBdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DBdyMULAA(B * df, B * sf)
    {
      if (serialized) DBdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DBdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else DBdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DBdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DBdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DBdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DBdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DBdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DBdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; B * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((B *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DBdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DBdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DBdyDIVSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DBdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DBdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DBdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DBdyDIVAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DBdyDIVAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DBdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DBdyDIVAA(B * df, B * sf)
    {
      if (serialized) DBdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DBdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else DBdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DBdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DBdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DBdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DBdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DBdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DBdyPWRSA(B* df, B *sf)
  {
    DBdyPWRSAs(df, sf);
  }

    static void DBdyPWRAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DBdyPWRAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DBdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DBdyPWRAA(B * df, B * sf)
    {
      if (serialized) DBdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DBdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else DBdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DBdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DBdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DBdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DBdyMODASs(df, sf);
#if ENABLE_THREADS
    else DBdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DBdyMODSA(B* df, B *sf)
  {
    DBdyMODSAs(df, sf);
  }

    static void DBdyMODAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DBdyMODAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DBdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DBdyMODAA(B * df, B * sf)
    {
      if (serialized) DBdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DBdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else DBdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DBdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DBdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DBdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DBdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DBdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((B *)NUM_VAL(sf))) == BINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DBdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DBdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DBdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DBdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DBdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; B * restrict s;
    s = (B *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DBdyTHEARCSA(B* df, B *sf)
  {
    DBdyTHEARCSAs(df, sf);
  }

    static void DBdyTHEARCAAp(B * df, B * sf)
    {
      L n; B * restrict s; D * restrict d;
      D t, tt;
      s = (B *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DBdyTHEARCAAs(B * df, B * sf)
    {
       L n; B * s; D * d;
       D t, tt;
       s = (B *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DBdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; B * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((B *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((B *)s++)) == BINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DBdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DBdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DBdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DBdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DBdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DBdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else DBdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DWdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DWdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DWdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DWdyADDASs(df, sf);
#if ENABLE_THREADS
    else DWdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DWdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DWdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DWdyADDSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DWdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DWdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DWdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyADDAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DWdyADDAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DWdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DWdyADDAA(B * df, B * sf)
    {
      if (serialized) DWdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DWdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else DWdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DWdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DWdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DWdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DWdySUBASs(df, sf);
#if ENABLE_THREADS
    else DWdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DWdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DWdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DWdySUBSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DWdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DWdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DWdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdySUBAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DWdySUBAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DWdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DWdySUBAA(B * df, B * sf)
    {
      if (serialized) DWdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DWdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else DWdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DWdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DWdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DWdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DWdyMULASs(df, sf);
#if ENABLE_THREADS
    else DWdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DWdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DWdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DWdyMULSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DWdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DWdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DWdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyMULAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DWdyMULAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DWdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DWdyMULAA(B * df, B * sf)
    {
      if (serialized) DWdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DWdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else DWdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DWdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DWdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DWdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DWdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DWdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DWdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; W * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((W *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DWdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DWdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DWdyDIVSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DWdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DWdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DWdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DWdyDIVAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DWdyDIVAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DWdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DWdyDIVAA(B * df, B * sf)
    {
      if (serialized) DWdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DWdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else DWdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DWdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DWdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DWdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DWdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DWdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DWdyPWRSA(B* df, B *sf)
  {
    DWdyPWRSAs(df, sf);
  }

    static void DWdyPWRAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DWdyPWRAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DWdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DWdyPWRAA(B * df, B * sf)
    {
      if (serialized) DWdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DWdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else DWdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DWdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DWdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DWdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DWdyMODASs(df, sf);
#if ENABLE_THREADS
    else DWdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DWdyMODSA(B* df, B *sf)
  {
    DWdyMODSAs(df, sf);
  }

    static void DWdyMODAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DWdyMODAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DWdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DWdyMODAA(B * df, B * sf)
    {
      if (serialized) DWdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DWdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else DWdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DWdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DWdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DWdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DWdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DWdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((W *)NUM_VAL(sf))) == WINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DWdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DWdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DWdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DWdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DWdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; W * restrict s;
    s = (W *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DWdyTHEARCSA(B* df, B *sf)
  {
    DWdyTHEARCSAs(df, sf);
  }

    static void DWdyTHEARCAAp(B * df, B * sf)
    {
      L n; W * restrict s; D * restrict d;
      D t, tt;
      s = (W *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DWdyTHEARCAAs(B * df, B * sf)
    {
       L n; W * s; D * d;
       D t, tt;
       s = (W *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DWdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; W * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((W *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((W *)s++)) == WINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DWdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DWdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DWdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DWdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DWdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DWdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else DWdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DLdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DLdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DLdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DLdyADDASs(df, sf);
#if ENABLE_THREADS
    else DLdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DLdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DLdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DLdyADDSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DLdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DLdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DLdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdyADDAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DLdyADDAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DLdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DLdyADDAA(B * df, B * sf)
    {
      if (serialized) DLdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DLdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else DLdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DLdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DLdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DLdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DLdySUBASs(df, sf);
#if ENABLE_THREADS
    else DLdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DLdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DLdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DLdySUBSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DLdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DLdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DLdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdySUBAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DLdySUBAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DLdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DLdySUBAA(B * df, B * sf)
    {
      if (serialized) DLdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DLdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else DLdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DLdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DLdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DLdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DLdyMULASs(df, sf);
#if ENABLE_THREADS
    else DLdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DLdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DLdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DLdyMULSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DLdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DLdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DLdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdyMULAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DLdyMULAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DLdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DLdyMULAA(B * df, B * sf)
    {
      if (serialized) DLdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DLdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else DLdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DLdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DLdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DLdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DLdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DLdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DLdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; L * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((L *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DLdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DLdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DLdyDIVSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DLdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DLdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DLdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DLdyDIVAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DLdyDIVAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DLdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DLdyDIVAA(B * df, B * sf)
    {
      if (serialized) DLdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DLdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else DLdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DLdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DLdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DLdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DLdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DLdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DLdyPWRSA(B* df, B *sf)
  {
    DLdyPWRSAs(df, sf);
  }

    static void DLdyPWRAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DLdyPWRAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DLdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DLdyPWRAA(B * df, B * sf)
    {
      if (serialized) DLdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DLdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else DLdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DLdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DLdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DLdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DLdyMODASs(df, sf);
#if ENABLE_THREADS
    else DLdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DLdyMODSA(B* df, B *sf)
  {
    DLdyMODSAs(df, sf);
  }

    static void DLdyMODAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DLdyMODAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DLdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DLdyMODAA(B * df, B * sf)
    {
      if (serialized) DLdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DLdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else DLdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DLdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DLdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DLdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DLdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DLdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
if ((tt = *((L *)NUM_VAL(sf))) == LINF) tt = DINF;
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DLdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DLdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DLdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DLdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DLdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; L * restrict s;
    s = (L *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DLdyTHEARCSA(B* df, B *sf)
  {
    DLdyTHEARCSAs(df, sf);
  }

    static void DLdyTHEARCAAp(B * df, B * sf)
    {
      L n; L * restrict s; D * restrict d;
      D t, tt;
      s = (L *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DLdyTHEARCAAs(B * df, B * sf)
    {
       L n; L * s; D * d;
       D t, tt;
       s = (L *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DLdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; L * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((L *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
if ((tt = *((L *)s++)) == LINF) tt = DINF;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DLdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DLdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DLdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DLdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DLdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DLdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else DLdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DSdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DSdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DSdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DSdyADDASs(df, sf);
#if ENABLE_THREADS
    else DSdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
tt = *((S *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DSdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DSdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DSdyADDSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DSdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DSdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DSdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyADDAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DSdyADDAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DSdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DSdyADDAA(B * df, B * sf)
    {
      if (serialized) DSdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DSdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else DSdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DSdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DSdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DSdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DSdySUBASs(df, sf);
#if ENABLE_THREADS
    else DSdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
tt = *((S *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DSdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DSdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DSdySUBSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DSdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DSdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DSdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdySUBAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DSdySUBAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DSdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DSdySUBAA(B * df, B * sf)
    {
      if (serialized) DSdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DSdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else DSdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DSdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DSdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DSdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DSdyMULASs(df, sf);
#if ENABLE_THREADS
    else DSdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
tt = *((S *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DSdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DSdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DSdyMULSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DSdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DSdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DSdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyMULAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DSdyMULAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DSdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DSdyMULAA(B * df, B * sf)
    {
      if (serialized) DSdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DSdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else DSdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DSdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DSdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DSdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DSdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DSdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DSdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; S * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((S *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
tt = *((S *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DSdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DSdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DSdyDIVSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DSdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DSdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DSdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DSdyDIVAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DSdyDIVAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DSdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DSdyDIVAA(B * df, B * sf)
    {
      if (serialized) DSdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DSdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else DSdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DSdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DSdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DSdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DSdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DSdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
tt = *((S *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DSdyPWRSA(B* df, B *sf)
  {
    DSdyPWRSAs(df, sf);
  }

    static void DSdyPWRAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DSdyPWRAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DSdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DSdyPWRAA(B * df, B * sf)
    {
      if (serialized) DSdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DSdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else DSdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DSdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DSdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DSdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DSdyMODASs(df, sf);
#if ENABLE_THREADS
    else DSdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
tt = *((S *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DSdyMODSA(B* df, B *sf)
  {
    DSdyMODSAs(df, sf);
  }

    static void DSdyMODAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DSdyMODAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DSdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DSdyMODAA(B * df, B * sf)
    {
      if (serialized) DSdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DSdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else DSdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DSdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((S *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DSdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((S *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DSdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DSdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DSdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((S *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DSdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DSdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DSdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DSdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DSdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; S * restrict s;
    s = (S *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
tt = *((S *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((S *)s++);
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DSdyTHEARCSA(B* df, B *sf)
  {
    DSdyTHEARCSAs(df, sf);
  }

    static void DSdyTHEARCAAp(B * df, B * sf)
    {
      L n; S * restrict s; D * restrict d;
      D t, tt;
      s = (S *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DSdyTHEARCAAs(B * df, B * sf)
    {
       L n; S * s; D * d;
       D t, tt;
       s = (S *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DSdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; S * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((S *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((S *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DSdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DSdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DSdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DSdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DSdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DSdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else DSdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DDdyADDSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t += tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyADDASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyADDASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DDdyADDASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DDdyADDASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDdyADDASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDdyADDAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DDdyADDASs(df, sf);
#if ENABLE_THREADS
    else DDdyADDASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyADDSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdyADDSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
tt = *((D *)s++);
t += tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t += tt;
}
    thread_share_lock();
     tt = data->out;
      
t += tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DDdyADDSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DDdyADDSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DDdyADDSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DDdyADDSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DDdyADDSAs(df, sf);
#if ENABLE_THREADS
    else DDdyADDSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyADDAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }

    static void DDdyADDAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DDdyADDAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t += tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyADDAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyADDAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyADDAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DDdyADDAA(B * df, B * sf)
    {
      if (serialized) DDdyADDAAs(df,sf);
#if ENABLE_THREADS
      else DDdyADDAAc(df,sf);
#else //!ENABLE_THREADS
      else DDdyADDAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DDdySUBSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t -= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdySUBASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdySUBASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DDdySUBASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DDdySUBASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDdySUBASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDdySUBAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DDdySUBASs(df, sf);
#if ENABLE_THREADS
    else DDdySUBASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdySUBSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdySUBSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
tt = *((D *)s++);
t -= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t -= tt;
}
    thread_share_lock();
     tt = data->out;
      
t -= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DDdySUBSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DDdySUBSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 0;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DDdySUBSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t += tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DDdySUBSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DDdySUBSAs(df, sf);
#if ENABLE_THREADS
    else DDdySUBSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdySUBAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }

    static void DDdySUBAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DDdySUBAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t -= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdySUBAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdySUBAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdySUBAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DDdySUBAA(B * df, B * sf)
    {
      if (serialized) DDdySUBAAs(df,sf);
#if ENABLE_THREADS
      else DDdySUBAAc(df,sf);
#else //!ENABLE_THREADS
      else DDdySUBAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DDdyMULSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t *= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyMULASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyMULASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DDdyMULASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DDdyMULASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDdyMULASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDdyMULAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DDdyMULASs(df, sf);
#if ENABLE_THREADS
    else DDdyMULASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyMULSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdyMULSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
tt = *((D *)s++);
t *= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t *= tt;
}
    thread_share_lock();
     tt = data->out;
      
t *= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DDdyMULSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DDdyMULSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DDdyMULSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DDdyMULSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DDdyMULSAs(df, sf);
#if ENABLE_THREADS
    else DDdyMULSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyMULAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }

    static void DDdyMULAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DDdyMULAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t *= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyMULAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyMULAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyMULAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DDdyMULAA(B * df, B * sf)
    {
      if (serialized) DDdyMULAAs(df,sf);
#if ENABLE_THREADS
      else DDdyMULAAc(df,sf);
#else //!ENABLE_THREADS
      else DDdyMULAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DDdyDIVSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t /= tt;
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyDIVASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyDIVASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    return OK;
  }

  static void DDdyDIVASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DDdyDIVASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDdyDIVASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDdyDIVAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DDdyDIVASs(df, sf);
#if ENABLE_THREADS
    else DDdyDIVASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyDIVSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
*((D *)NUM_VAL(df)) = t;
   }

#if ENABLE_THREADS
 static L DDdyDIVSAt(UL id, B* indata)
 {
    thread_array_data* data = (thread_array_data*) indata;
    D t,tt; L n, n_; D * restrict s;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    s = ((D *) data->sf_start)+data->perthread*id;
    t = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
tt = *((D *)s++);
t /= tt;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t /= tt;
}
    thread_share_lock();
     tt = data->out;
      
t /= tt;
      data->out = t;
    thread_share_unlock();
    return OK;
  }  
    
  static void DDdyDIVSAc(B* df, B* sf)
  {
    UL nways; thread_array_data data; D t,tt;
    if (thread_num == 1 || ARRAY_SIZE(sf)/(THREADMUL*8) < 1)
      DDdyDIVSAs(df, sf);
    else {
      nways = ARRAY_SIZE(sf)/(THREADMUL*8)
              + (ARRAY_SIZE(sf)%(THREADMUL*8) ?
                 1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.sf_start = VALUE_PTR(sf);
      data.out = data.in = 1;
      data.perthread = ARRAY_SIZE(sf) / nways;
      data.leftover = ARRAY_SIZE(sf) % nways;
      threads_do(nways, DDdyDIVSAt, (B*) &data);
      
t = *((D *)NUM_VAL(df));
      tt = data.out;
      
t *= tt;
*((D *)NUM_VAL(df)) = t;
    }
  }
#endif //ENABLE_THREADS

  static void DDdyDIVSA(B* df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
      DDdyDIVSAs(df, sf);
#if ENABLE_THREADS
    else DDdyDIVSAc(df, sf);
#endif //ENABLE_THREADS
  }

    static void DDdyDIVAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }

    static void DDdyDIVAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DDdyDIVAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t /= tt;
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyDIVAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyDIVAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyDIVAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DDdyDIVAA(B * df, B * sf)
    {
      if (serialized) DDdyDIVAAs(df,sf);
#if ENABLE_THREADS
      else DDdyDIVAAc(df,sf);
#else //!ENABLE_THREADS
      else DDdyDIVAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DDdyPWRSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = pow(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyPWRASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyPWRASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DDdyPWRASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DDdyPWRASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDdyPWRASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDdyPWRAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DDdyPWRASs(df, sf);
#if ENABLE_THREADS
    else DDdyPWRASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyPWRSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
tt = *((D *)s++);
t = pow(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = pow(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DDdyPWRSA(B* df, B *sf)
  {
    DDdyPWRSAs(df, sf);
  }

    static void DDdyPWRAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }

    static void DDdyPWRAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DDdyPWRAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = pow(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyPWRAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyPWRAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyPWRAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DDdyPWRAA(B * df, B * sf)
    {
      if (serialized) DDdyPWRAAs(df,sf);
#if ENABLE_THREADS
      else DDdyPWRAAc(df,sf);
#else //!ENABLE_THREADS
      else DDdyPWRAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DDdyMODSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = fmod(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyMODASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyMODASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DDdyMODASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DDdyMODASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDdyMODASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDdyMODAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DDdyMODASs(df, sf);
#if ENABLE_THREADS
    else DDdyMODASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyMODSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
tt = *((D *)s++);
t = fmod(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = fmod(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DDdyMODSA(B* df, B *sf)
  {
    DDdyMODSAs(df, sf);
  }

    static void DDdyMODAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }

    static void DDdyMODAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DDdyMODAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = fmod(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyMODAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyMODAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyMODAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DDdyMODAA(B * df, B * sf)
    {
      if (serialized) DDdyMODAAs(df,sf);
#if ENABLE_THREADS
      else DDdyMODAAc(df,sf);
#else //!ENABLE_THREADS
      else DDdyMODAAp(df,sf);
#endif //!ENABLE_THREADS
    }

static void DDdyTHEARCSS(B *df, B *sf)
{
D t, tt;
t = *((D *)NUM_VAL(df));
tt = *((D *)NUM_VAL(sf));
t = thearc(t,tt);
*((D *)NUM_VAL(df)) = t;
}

  static void DDdyTHEARCASs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict d;
    d = (D *)VALUE_BASE(df);
tt = *((D *)NUM_VAL(sf));
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
  }

#if ENABLE_THREADS
  static L DDdyTHEARCASt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t, tt; L n, n_; D * restrict d;
    n_ = data->perthread;
    if (thread_max == id) n += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
    tt = data->in;
    
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    return OK;
  }

  static void DDdyTHEARCASc(B* df, B *sf)
  {
    UL nways; thread_array_data data; D tt;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DDdyTHEARCASs(df, sf);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      
tt = *((D *)NUM_VAL(sf));
      data.in = tt;
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DDdyTHEARCASt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DDdyTHEARCAS(B *df, B *sf)
  {
#if ENABLE_THREADS
    if (serialized)
#endif //ENABLE_THREADS
    DDdyTHEARCASs(df, sf);
#if ENABLE_THREADS
    else DDdyTHEARCASc(df, sf);
#endif //ENABLE_THREADS
  }

  static void DDdyTHEARCSAs(B *df, B *sf)
  {
    D t,tt; L n; D * restrict s;
    s = (D *)VALUE_BASE(sf);
t = *((D *)NUM_VAL(df));
for (n = (ARRAY_SIZE(sf)>>3); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
tt = *((D *)s++);
t = thearc(t,tt);
}
for (n = (ARRAY_SIZE(sf)&7); n>0; n--) {
tt = *((D *)s++);
t = thearc(t,tt);
}
*((D *)NUM_VAL(df)) = t;
   }

  static void DDdyTHEARCSA(B* df, B *sf)
  {
    DDdyTHEARCSAs(df, sf);
  }

    static void DDdyTHEARCAAp(B * df, B * sf)
    {
      L n; D * restrict s; D * restrict d;
      D t, tt;
      s = (D *)VALUE_BASE(sf);
      d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }

    static void DDdyTHEARCAAs(B * df, B * sf)
    {
       L n; D * s; D * d;
       D t, tt;
       s = (D *)VALUE_BASE(sf);
       d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
    }


#ifdef ENABLE_THREADS
    static L DDdyTHEARCAAt(UL id, B* indata) 
    {
      thread_array_data* data = (thread_array_data*) indata;
      D t, tt; L n, n_; D * s; D * d;
      n_ = data->perthread;
      if (thread_max == id) n_ += data->leftover;
      s = ((D *) data->sf_start)+data->perthread*id;
      d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
tt = *((D *)s++);
t = *((D *)d);
t = thearc(t,tt);
*((D *)d++) = t;
}
      return OK;
    }

    static void DDdyTHEARCAAc(B* df, B* sf)
    {
       UL nways; thread_array_data data;
       if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
          DDdyTHEARCAAp(df, sf);
       else {
         nways = ARRAY_SIZE(df)/(THREADMUL*8)
                 + (ARRAY_SIZE(df)%(THREADMUL*8) ?
                     1 : 0);
         if (nways > thread_num) nways = thread_num;
         data.sf_start = VALUE_PTR(sf);
         data.df_start = VALUE_PTR(df);
         data.perthread = ARRAY_SIZE(df) / nways;
         data.leftover = ARRAY_SIZE(df) % nways;
         threads_do(nways, DDdyTHEARCAAt, (B*) &data);
       }
     }
#endif //ENABLE_THREADS

    static void DDdyTHEARCAA(B * df, B * sf)
    {
      if (serialized) DDdyTHEARCAAs(df,sf);
#if ENABLE_THREADS
      else DDdyTHEARCAAc(df,sf);
#else //!ENABLE_THREADS
      else DDdyTHEARCAAp(df,sf);
#endif //!ENABLE_THREADS
    }

typedef void (*dyadic_fct)(B*,B*);
static dyadic_fct ADDlist[] = {
BBdyADDSS, BBdyADDAS, BBdyADDSA, BBdyADDAA, 
BWdyADDSS, BWdyADDAS, BWdyADDSA, BWdyADDAA, 
BLdyADDSS, BLdyADDAS, BLdyADDSA, BLdyADDAA, 
BSdyADDSS, BSdyADDAS, BSdyADDSA, BSdyADDAA, 
BDdyADDSS, BDdyADDAS, BDdyADDSA, BDdyADDAA, 
WBdyADDSS, WBdyADDAS, WBdyADDSA, WBdyADDAA, 
WWdyADDSS, WWdyADDAS, WWdyADDSA, WWdyADDAA, 
WLdyADDSS, WLdyADDAS, WLdyADDSA, WLdyADDAA, 
WSdyADDSS, WSdyADDAS, WSdyADDSA, WSdyADDAA, 
WDdyADDSS, WDdyADDAS, WDdyADDSA, WDdyADDAA, 
LBdyADDSS, LBdyADDAS, LBdyADDSA, LBdyADDAA, 
LWdyADDSS, LWdyADDAS, LWdyADDSA, LWdyADDAA, 
LLdyADDSS, LLdyADDAS, LLdyADDSA, LLdyADDAA, 
LSdyADDSS, LSdyADDAS, LSdyADDSA, LSdyADDAA, 
LDdyADDSS, LDdyADDAS, LDdyADDSA, LDdyADDAA, 
SBdyADDSS, SBdyADDAS, SBdyADDSA, SBdyADDAA, 
SWdyADDSS, SWdyADDAS, SWdyADDSA, SWdyADDAA, 
SLdyADDSS, SLdyADDAS, SLdyADDSA, SLdyADDAA, 
SSdyADDSS, SSdyADDAS, SSdyADDSA, SSdyADDAA, 
SDdyADDSS, SDdyADDAS, SDdyADDSA, SDdyADDAA, 
DBdyADDSS, DBdyADDAS, DBdyADDSA, DBdyADDAA, 
DWdyADDSS, DWdyADDAS, DWdyADDSA, DWdyADDAA, 
DLdyADDSS, DLdyADDAS, DLdyADDSA, DLdyADDAA, 
DSdyADDSS, DSdyADDAS, DSdyADDSA, DSdyADDAA, 
DDdyADDSS, DDdyADDAS, DDdyADDSA, DDdyADDAA, 

};
static dyadic_fct SUBlist[] = {
BBdySUBSS, BBdySUBAS, BBdySUBSA, BBdySUBAA, 
BWdySUBSS, BWdySUBAS, BWdySUBSA, BWdySUBAA, 
BLdySUBSS, BLdySUBAS, BLdySUBSA, BLdySUBAA, 
BSdySUBSS, BSdySUBAS, BSdySUBSA, BSdySUBAA, 
BDdySUBSS, BDdySUBAS, BDdySUBSA, BDdySUBAA, 
WBdySUBSS, WBdySUBAS, WBdySUBSA, WBdySUBAA, 
WWdySUBSS, WWdySUBAS, WWdySUBSA, WWdySUBAA, 
WLdySUBSS, WLdySUBAS, WLdySUBSA, WLdySUBAA, 
WSdySUBSS, WSdySUBAS, WSdySUBSA, WSdySUBAA, 
WDdySUBSS, WDdySUBAS, WDdySUBSA, WDdySUBAA, 
LBdySUBSS, LBdySUBAS, LBdySUBSA, LBdySUBAA, 
LWdySUBSS, LWdySUBAS, LWdySUBSA, LWdySUBAA, 
LLdySUBSS, LLdySUBAS, LLdySUBSA, LLdySUBAA, 
LSdySUBSS, LSdySUBAS, LSdySUBSA, LSdySUBAA, 
LDdySUBSS, LDdySUBAS, LDdySUBSA, LDdySUBAA, 
SBdySUBSS, SBdySUBAS, SBdySUBSA, SBdySUBAA, 
SWdySUBSS, SWdySUBAS, SWdySUBSA, SWdySUBAA, 
SLdySUBSS, SLdySUBAS, SLdySUBSA, SLdySUBAA, 
SSdySUBSS, SSdySUBAS, SSdySUBSA, SSdySUBAA, 
SDdySUBSS, SDdySUBAS, SDdySUBSA, SDdySUBAA, 
DBdySUBSS, DBdySUBAS, DBdySUBSA, DBdySUBAA, 
DWdySUBSS, DWdySUBAS, DWdySUBSA, DWdySUBAA, 
DLdySUBSS, DLdySUBAS, DLdySUBSA, DLdySUBAA, 
DSdySUBSS, DSdySUBAS, DSdySUBSA, DSdySUBAA, 
DDdySUBSS, DDdySUBAS, DDdySUBSA, DDdySUBAA, 

};
static dyadic_fct MULlist[] = {
BBdyMULSS, BBdyMULAS, BBdyMULSA, BBdyMULAA, 
BWdyMULSS, BWdyMULAS, BWdyMULSA, BWdyMULAA, 
BLdyMULSS, BLdyMULAS, BLdyMULSA, BLdyMULAA, 
BSdyMULSS, BSdyMULAS, BSdyMULSA, BSdyMULAA, 
BDdyMULSS, BDdyMULAS, BDdyMULSA, BDdyMULAA, 
WBdyMULSS, WBdyMULAS, WBdyMULSA, WBdyMULAA, 
WWdyMULSS, WWdyMULAS, WWdyMULSA, WWdyMULAA, 
WLdyMULSS, WLdyMULAS, WLdyMULSA, WLdyMULAA, 
WSdyMULSS, WSdyMULAS, WSdyMULSA, WSdyMULAA, 
WDdyMULSS, WDdyMULAS, WDdyMULSA, WDdyMULAA, 
LBdyMULSS, LBdyMULAS, LBdyMULSA, LBdyMULAA, 
LWdyMULSS, LWdyMULAS, LWdyMULSA, LWdyMULAA, 
LLdyMULSS, LLdyMULAS, LLdyMULSA, LLdyMULAA, 
LSdyMULSS, LSdyMULAS, LSdyMULSA, LSdyMULAA, 
LDdyMULSS, LDdyMULAS, LDdyMULSA, LDdyMULAA, 
SBdyMULSS, SBdyMULAS, SBdyMULSA, SBdyMULAA, 
SWdyMULSS, SWdyMULAS, SWdyMULSA, SWdyMULAA, 
SLdyMULSS, SLdyMULAS, SLdyMULSA, SLdyMULAA, 
SSdyMULSS, SSdyMULAS, SSdyMULSA, SSdyMULAA, 
SDdyMULSS, SDdyMULAS, SDdyMULSA, SDdyMULAA, 
DBdyMULSS, DBdyMULAS, DBdyMULSA, DBdyMULAA, 
DWdyMULSS, DWdyMULAS, DWdyMULSA, DWdyMULAA, 
DLdyMULSS, DLdyMULAS, DLdyMULSA, DLdyMULAA, 
DSdyMULSS, DSdyMULAS, DSdyMULSA, DSdyMULAA, 
DDdyMULSS, DDdyMULAS, DDdyMULSA, DDdyMULAA, 

};
static dyadic_fct DIVlist[] = {
BBdyDIVSS, BBdyDIVAS, BBdyDIVSA, BBdyDIVAA, 
BWdyDIVSS, BWdyDIVAS, BWdyDIVSA, BWdyDIVAA, 
BLdyDIVSS, BLdyDIVAS, BLdyDIVSA, BLdyDIVAA, 
BSdyDIVSS, BSdyDIVAS, BSdyDIVSA, BSdyDIVAA, 
BDdyDIVSS, BDdyDIVAS, BDdyDIVSA, BDdyDIVAA, 
WBdyDIVSS, WBdyDIVAS, WBdyDIVSA, WBdyDIVAA, 
WWdyDIVSS, WWdyDIVAS, WWdyDIVSA, WWdyDIVAA, 
WLdyDIVSS, WLdyDIVAS, WLdyDIVSA, WLdyDIVAA, 
WSdyDIVSS, WSdyDIVAS, WSdyDIVSA, WSdyDIVAA, 
WDdyDIVSS, WDdyDIVAS, WDdyDIVSA, WDdyDIVAA, 
LBdyDIVSS, LBdyDIVAS, LBdyDIVSA, LBdyDIVAA, 
LWdyDIVSS, LWdyDIVAS, LWdyDIVSA, LWdyDIVAA, 
LLdyDIVSS, LLdyDIVAS, LLdyDIVSA, LLdyDIVAA, 
LSdyDIVSS, LSdyDIVAS, LSdyDIVSA, LSdyDIVAA, 
LDdyDIVSS, LDdyDIVAS, LDdyDIVSA, LDdyDIVAA, 
SBdyDIVSS, SBdyDIVAS, SBdyDIVSA, SBdyDIVAA, 
SWdyDIVSS, SWdyDIVAS, SWdyDIVSA, SWdyDIVAA, 
SLdyDIVSS, SLdyDIVAS, SLdyDIVSA, SLdyDIVAA, 
SSdyDIVSS, SSdyDIVAS, SSdyDIVSA, SSdyDIVAA, 
SDdyDIVSS, SDdyDIVAS, SDdyDIVSA, SDdyDIVAA, 
DBdyDIVSS, DBdyDIVAS, DBdyDIVSA, DBdyDIVAA, 
DWdyDIVSS, DWdyDIVAS, DWdyDIVSA, DWdyDIVAA, 
DLdyDIVSS, DLdyDIVAS, DLdyDIVSA, DLdyDIVAA, 
DSdyDIVSS, DSdyDIVAS, DSdyDIVSA, DSdyDIVAA, 
DDdyDIVSS, DDdyDIVAS, DDdyDIVSA, DDdyDIVAA, 

};
static dyadic_fct PWRlist[] = {
BBdyPWRSS, BBdyPWRAS, BBdyPWRSA, BBdyPWRAA, 
BWdyPWRSS, BWdyPWRAS, BWdyPWRSA, BWdyPWRAA, 
BLdyPWRSS, BLdyPWRAS, BLdyPWRSA, BLdyPWRAA, 
BSdyPWRSS, BSdyPWRAS, BSdyPWRSA, BSdyPWRAA, 
BDdyPWRSS, BDdyPWRAS, BDdyPWRSA, BDdyPWRAA, 
WBdyPWRSS, WBdyPWRAS, WBdyPWRSA, WBdyPWRAA, 
WWdyPWRSS, WWdyPWRAS, WWdyPWRSA, WWdyPWRAA, 
WLdyPWRSS, WLdyPWRAS, WLdyPWRSA, WLdyPWRAA, 
WSdyPWRSS, WSdyPWRAS, WSdyPWRSA, WSdyPWRAA, 
WDdyPWRSS, WDdyPWRAS, WDdyPWRSA, WDdyPWRAA, 
LBdyPWRSS, LBdyPWRAS, LBdyPWRSA, LBdyPWRAA, 
LWdyPWRSS, LWdyPWRAS, LWdyPWRSA, LWdyPWRAA, 
LLdyPWRSS, LLdyPWRAS, LLdyPWRSA, LLdyPWRAA, 
LSdyPWRSS, LSdyPWRAS, LSdyPWRSA, LSdyPWRAA, 
LDdyPWRSS, LDdyPWRAS, LDdyPWRSA, LDdyPWRAA, 
SBdyPWRSS, SBdyPWRAS, SBdyPWRSA, SBdyPWRAA, 
SWdyPWRSS, SWdyPWRAS, SWdyPWRSA, SWdyPWRAA, 
SLdyPWRSS, SLdyPWRAS, SLdyPWRSA, SLdyPWRAA, 
SSdyPWRSS, SSdyPWRAS, SSdyPWRSA, SSdyPWRAA, 
SDdyPWRSS, SDdyPWRAS, SDdyPWRSA, SDdyPWRAA, 
DBdyPWRSS, DBdyPWRAS, DBdyPWRSA, DBdyPWRAA, 
DWdyPWRSS, DWdyPWRAS, DWdyPWRSA, DWdyPWRAA, 
DLdyPWRSS, DLdyPWRAS, DLdyPWRSA, DLdyPWRAA, 
DSdyPWRSS, DSdyPWRAS, DSdyPWRSA, DSdyPWRAA, 
DDdyPWRSS, DDdyPWRAS, DDdyPWRSA, DDdyPWRAA, 

};
static dyadic_fct MODlist[] = {
BBdyMODSS, BBdyMODAS, BBdyMODSA, BBdyMODAA, 
BWdyMODSS, BWdyMODAS, BWdyMODSA, BWdyMODAA, 
BLdyMODSS, BLdyMODAS, BLdyMODSA, BLdyMODAA, 
BSdyMODSS, BSdyMODAS, BSdyMODSA, BSdyMODAA, 
BDdyMODSS, BDdyMODAS, BDdyMODSA, BDdyMODAA, 
WBdyMODSS, WBdyMODAS, WBdyMODSA, WBdyMODAA, 
WWdyMODSS, WWdyMODAS, WWdyMODSA, WWdyMODAA, 
WLdyMODSS, WLdyMODAS, WLdyMODSA, WLdyMODAA, 
WSdyMODSS, WSdyMODAS, WSdyMODSA, WSdyMODAA, 
WDdyMODSS, WDdyMODAS, WDdyMODSA, WDdyMODAA, 
LBdyMODSS, LBdyMODAS, LBdyMODSA, LBdyMODAA, 
LWdyMODSS, LWdyMODAS, LWdyMODSA, LWdyMODAA, 
LLdyMODSS, LLdyMODAS, LLdyMODSA, LLdyMODAA, 
LSdyMODSS, LSdyMODAS, LSdyMODSA, LSdyMODAA, 
LDdyMODSS, LDdyMODAS, LDdyMODSA, LDdyMODAA, 
SBdyMODSS, SBdyMODAS, SBdyMODSA, SBdyMODAA, 
SWdyMODSS, SWdyMODAS, SWdyMODSA, SWdyMODAA, 
SLdyMODSS, SLdyMODAS, SLdyMODSA, SLdyMODAA, 
SSdyMODSS, SSdyMODAS, SSdyMODSA, SSdyMODAA, 
SDdyMODSS, SDdyMODAS, SDdyMODSA, SDdyMODAA, 
DBdyMODSS, DBdyMODAS, DBdyMODSA, DBdyMODAA, 
DWdyMODSS, DWdyMODAS, DWdyMODSA, DWdyMODAA, 
DLdyMODSS, DLdyMODAS, DLdyMODSA, DLdyMODAA, 
DSdyMODSS, DSdyMODAS, DSdyMODSA, DSdyMODAA, 
DDdyMODSS, DDdyMODAS, DDdyMODSA, DDdyMODAA, 

};
static dyadic_fct THEARClist[] = {
BBdyTHEARCSS, BBdyTHEARCAS, BBdyTHEARCSA, BBdyTHEARCAA, 
BWdyTHEARCSS, BWdyTHEARCAS, BWdyTHEARCSA, BWdyTHEARCAA, 
BLdyTHEARCSS, BLdyTHEARCAS, BLdyTHEARCSA, BLdyTHEARCAA, 
BSdyTHEARCSS, BSdyTHEARCAS, BSdyTHEARCSA, BSdyTHEARCAA, 
BDdyTHEARCSS, BDdyTHEARCAS, BDdyTHEARCSA, BDdyTHEARCAA, 
WBdyTHEARCSS, WBdyTHEARCAS, WBdyTHEARCSA, WBdyTHEARCAA, 
WWdyTHEARCSS, WWdyTHEARCAS, WWdyTHEARCSA, WWdyTHEARCAA, 
WLdyTHEARCSS, WLdyTHEARCAS, WLdyTHEARCSA, WLdyTHEARCAA, 
WSdyTHEARCSS, WSdyTHEARCAS, WSdyTHEARCSA, WSdyTHEARCAA, 
WDdyTHEARCSS, WDdyTHEARCAS, WDdyTHEARCSA, WDdyTHEARCAA, 
LBdyTHEARCSS, LBdyTHEARCAS, LBdyTHEARCSA, LBdyTHEARCAA, 
LWdyTHEARCSS, LWdyTHEARCAS, LWdyTHEARCSA, LWdyTHEARCAA, 
LLdyTHEARCSS, LLdyTHEARCAS, LLdyTHEARCSA, LLdyTHEARCAA, 
LSdyTHEARCSS, LSdyTHEARCAS, LSdyTHEARCSA, LSdyTHEARCAA, 
LDdyTHEARCSS, LDdyTHEARCAS, LDdyTHEARCSA, LDdyTHEARCAA, 
SBdyTHEARCSS, SBdyTHEARCAS, SBdyTHEARCSA, SBdyTHEARCAA, 
SWdyTHEARCSS, SWdyTHEARCAS, SWdyTHEARCSA, SWdyTHEARCAA, 
SLdyTHEARCSS, SLdyTHEARCAS, SLdyTHEARCSA, SLdyTHEARCAA, 
SSdyTHEARCSS, SSdyTHEARCAS, SSdyTHEARCSA, SSdyTHEARCAA, 
SDdyTHEARCSS, SDdyTHEARCAS, SDdyTHEARCSA, SDdyTHEARCAA, 
DBdyTHEARCSS, DBdyTHEARCAS, DBdyTHEARCSA, DBdyTHEARCAA, 
DWdyTHEARCSS, DWdyTHEARCAS, DWdyTHEARCSA, DWdyTHEARCAA, 
DLdyTHEARCSS, DLdyTHEARCAS, DLdyTHEARCSA, DLdyTHEARCAA, 
DSdyTHEARCSS, DSdyTHEARCAS, DSdyTHEARCSA, DSdyTHEARCAA, 
DDdyTHEARCSS, DDdyTHEARCAS, DDdyTHEARCSA, DDdyTHEARCAA, 

};

static void BmoNEGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = -t;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoNEGAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoNEGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = -t;
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoNEGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoNEGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoNEGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoNEGA(B *df)
  {
#if !ENABLE_THREADS
    BmoNEGAs(df);
#else //ENABLE_THREADS
    BmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void BmoABSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = fabs(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoABSAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoABSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = fabs(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoABSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoABSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoABSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoABSA(B *df)
  {
#if !ENABLE_THREADS
    BmoABSAs(df);
#else //ENABLE_THREADS
    BmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoSQRTS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = sqrt(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoSQRTAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoSQRTAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sqrt(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoSQRTAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoSQRTAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoSQRTAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoSQRTA(B *df)
  {
#if !ENABLE_THREADS
    BmoSQRTAs(df);
#else //ENABLE_THREADS
    BmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void BmoEXPS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = exp(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoEXPAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoEXPAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = exp(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoEXPAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoEXPAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoEXPAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoEXPA(B *df)
  {
#if !ENABLE_THREADS
    BmoEXPAs(df);
#else //ENABLE_THREADS
    BmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void BmoLNS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = log(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoLNAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoLNAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoLNAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoLNAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoLNAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoLNA(B *df)
  {
#if !ENABLE_THREADS
    BmoLNAs(df);
#else //ENABLE_THREADS
    BmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void BmoLGS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = log10(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoLGAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoLGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = log10(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoLGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoLGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoLGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoLGA(B *df)
  {
#if !ENABLE_THREADS
    BmoLGAs(df);
#else //ENABLE_THREADS
    BmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void BmoFLOORS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = floor(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoFLOORAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoFLOORAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = floor(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoFLOORAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoFLOORAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoFLOORAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoFLOORA(B *df)
  {
#if !ENABLE_THREADS
    BmoFLOORAs(df);
#else //ENABLE_THREADS
    BmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void BmoCEILS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = ceil(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoCEILAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoCEILAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = ceil(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoCEILAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoCEILAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoCEILAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoCEILA(B *df)
  {
#if !ENABLE_THREADS
    BmoCEILAs(df);
#else //ENABLE_THREADS
    BmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void BmoSINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = sin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoSINAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoSINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = sin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoSINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoSINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoSINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoSINA(B *df)
  {
#if !ENABLE_THREADS
    BmoSINAs(df);
#else //ENABLE_THREADS
    BmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void BmoCOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = cos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoCOSAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoCOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = cos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoCOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoCOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoCOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoCOSA(B *df)
  {
#if !ENABLE_THREADS
    BmoCOSAs(df);
#else //ENABLE_THREADS
    BmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoTANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = tan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoTANAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoTANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = tan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoTANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoTANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoTANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoTANA(B *df)
  {
#if !ENABLE_THREADS
    BmoTANAs(df);
#else //ENABLE_THREADS
    BmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void BmoASINS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = asin(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoASINAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoASINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = asin(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoASINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoASINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoASINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoASINA(B *df)
  {
#if !ENABLE_THREADS
    BmoASINAs(df);
#else //ENABLE_THREADS
    BmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void BmoACOSS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = acos(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoACOSAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoACOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = acos(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoACOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoACOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoACOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoACOSA(B *df)
  {
#if !ENABLE_THREADS
    BmoACOSAs(df);
#else //ENABLE_THREADS
    BmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void BmoATANS(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t = atan(t);
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

   static void BmoATANAs(B *df)
   {
     D t; B *d; L n;
     d = (B *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
   }

#if ENABLE_THREADS
  static L BmoATANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; B * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((B *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((B *)d)) == BINF) t = DINF;
t = atan(t);
*((B *)d++) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}
    return OK;
  }
    
  static void BmoATANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      BmoATANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, BmoATANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void BmoATANA(B *df)
  {
#if !ENABLE_THREADS
    BmoATANAs(df);
#else //ENABLE_THREADS
    BmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void WmoNEGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = -t;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoNEGAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoNEGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = -t;
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoNEGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoNEGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoNEGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoNEGA(B *df)
  {
#if !ENABLE_THREADS
    WmoNEGAs(df);
#else //ENABLE_THREADS
    WmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void WmoABSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = fabs(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoABSAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoABSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = fabs(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoABSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoABSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoABSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoABSA(B *df)
  {
#if !ENABLE_THREADS
    WmoABSAs(df);
#else //ENABLE_THREADS
    WmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoSQRTS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = sqrt(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoSQRTAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoSQRTAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sqrt(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoSQRTAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoSQRTAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoSQRTAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoSQRTA(B *df)
  {
#if !ENABLE_THREADS
    WmoSQRTAs(df);
#else //ENABLE_THREADS
    WmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void WmoEXPS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = exp(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoEXPAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoEXPAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = exp(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoEXPAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoEXPAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoEXPAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoEXPA(B *df)
  {
#if !ENABLE_THREADS
    WmoEXPAs(df);
#else //ENABLE_THREADS
    WmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void WmoLNS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = log(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoLNAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoLNAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoLNAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoLNAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoLNAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoLNA(B *df)
  {
#if !ENABLE_THREADS
    WmoLNAs(df);
#else //ENABLE_THREADS
    WmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void WmoLGS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = log10(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoLGAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoLGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = log10(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoLGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoLGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoLGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoLGA(B *df)
  {
#if !ENABLE_THREADS
    WmoLGAs(df);
#else //ENABLE_THREADS
    WmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void WmoFLOORS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = floor(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoFLOORAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoFLOORAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = floor(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoFLOORAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoFLOORAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoFLOORAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoFLOORA(B *df)
  {
#if !ENABLE_THREADS
    WmoFLOORAs(df);
#else //ENABLE_THREADS
    WmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void WmoCEILS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = ceil(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoCEILAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoCEILAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = ceil(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoCEILAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoCEILAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoCEILAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoCEILA(B *df)
  {
#if !ENABLE_THREADS
    WmoCEILAs(df);
#else //ENABLE_THREADS
    WmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void WmoSINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = sin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoSINAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoSINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = sin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoSINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoSINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoSINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoSINA(B *df)
  {
#if !ENABLE_THREADS
    WmoSINAs(df);
#else //ENABLE_THREADS
    WmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void WmoCOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = cos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoCOSAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoCOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = cos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoCOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoCOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoCOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoCOSA(B *df)
  {
#if !ENABLE_THREADS
    WmoCOSAs(df);
#else //ENABLE_THREADS
    WmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoTANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = tan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoTANAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoTANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = tan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoTANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoTANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoTANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoTANA(B *df)
  {
#if !ENABLE_THREADS
    WmoTANAs(df);
#else //ENABLE_THREADS
    WmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void WmoASINS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = asin(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoASINAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoASINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = asin(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoASINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoASINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoASINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoASINA(B *df)
  {
#if !ENABLE_THREADS
    WmoASINAs(df);
#else //ENABLE_THREADS
    WmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void WmoACOSS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = acos(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoACOSAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoACOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = acos(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoACOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoACOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoACOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoACOSA(B *df)
  {
#if !ENABLE_THREADS
    WmoACOSAs(df);
#else //ENABLE_THREADS
    WmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void WmoATANS(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t = atan(t);
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

   static void WmoATANAs(B *df)
   {
     D t; W *d; L n;
     d = (W *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
   }

#if ENABLE_THREADS
  static L WmoATANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; W * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((W *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((W *)d)) == WINF) t = DINF;
t = atan(t);
*((W *)d++) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}
    return OK;
  }
    
  static void WmoATANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      WmoATANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, WmoATANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void WmoATANA(B *df)
  {
#if !ENABLE_THREADS
    WmoATANAs(df);
#else //ENABLE_THREADS
    WmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void LmoNEGS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = -t;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoNEGAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoNEGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = -t;
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoNEGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoNEGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoNEGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoNEGA(B *df)
  {
#if !ENABLE_THREADS
    LmoNEGAs(df);
#else //ENABLE_THREADS
    LmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void LmoABSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = fabs(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoABSAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoABSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = fabs(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoABSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoABSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoABSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoABSA(B *df)
  {
#if !ENABLE_THREADS
    LmoABSAs(df);
#else //ENABLE_THREADS
    LmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void LmoSQRTS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = sqrt(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoSQRTAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoSQRTAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sqrt(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoSQRTAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoSQRTAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoSQRTAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoSQRTA(B *df)
  {
#if !ENABLE_THREADS
    LmoSQRTAs(df);
#else //ENABLE_THREADS
    LmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void LmoEXPS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = exp(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoEXPAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoEXPAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = exp(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoEXPAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoEXPAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoEXPAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoEXPA(B *df)
  {
#if !ENABLE_THREADS
    LmoEXPAs(df);
#else //ENABLE_THREADS
    LmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void LmoLNS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = log(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoLNAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoLNAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoLNAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoLNAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoLNAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoLNA(B *df)
  {
#if !ENABLE_THREADS
    LmoLNAs(df);
#else //ENABLE_THREADS
    LmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void LmoLGS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = log10(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoLGAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoLGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = log10(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoLGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoLGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoLGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoLGA(B *df)
  {
#if !ENABLE_THREADS
    LmoLGAs(df);
#else //ENABLE_THREADS
    LmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void LmoFLOORS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = floor(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoFLOORAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoFLOORAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = floor(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoFLOORAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoFLOORAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoFLOORAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoFLOORA(B *df)
  {
#if !ENABLE_THREADS
    LmoFLOORAs(df);
#else //ENABLE_THREADS
    LmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void LmoCEILS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = ceil(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoCEILAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoCEILAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = ceil(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoCEILAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoCEILAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoCEILAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoCEILA(B *df)
  {
#if !ENABLE_THREADS
    LmoCEILAs(df);
#else //ENABLE_THREADS
    LmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void LmoSINS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = sin(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoSINAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoSINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = sin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoSINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoSINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoSINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoSINA(B *df)
  {
#if !ENABLE_THREADS
    LmoSINAs(df);
#else //ENABLE_THREADS
    LmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void LmoCOSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = cos(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoCOSAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoCOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = cos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoCOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoCOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoCOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoCOSA(B *df)
  {
#if !ENABLE_THREADS
    LmoCOSAs(df);
#else //ENABLE_THREADS
    LmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void LmoTANS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = tan(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoTANAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoTANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = tan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoTANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoTANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoTANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoTANA(B *df)
  {
#if !ENABLE_THREADS
    LmoTANAs(df);
#else //ENABLE_THREADS
    LmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void LmoASINS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = asin(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoASINAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoASINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = asin(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoASINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoASINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoASINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoASINA(B *df)
  {
#if !ENABLE_THREADS
    LmoASINAs(df);
#else //ENABLE_THREADS
    LmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void LmoACOSS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = acos(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoACOSAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoACOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = acos(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoACOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoACOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoACOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoACOSA(B *df)
  {
#if !ENABLE_THREADS
    LmoACOSAs(df);
#else //ENABLE_THREADS
    LmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void LmoATANS(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t = atan(t);
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

   static void LmoATANAs(B *df)
   {
     D t; L *d; L n;
     d = (L *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
   }

#if ENABLE_THREADS
  static L LmoATANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; L * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((L *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
for (n = (n_ & 7); n>0; n--) {
if ((t = *((L *)d)) == LINF) t = DINF;
t = atan(t);
*((L *)d++) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}
    return OK;
  }
    
  static void LmoATANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      LmoATANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, LmoATANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void LmoATANA(B *df)
  {
#if !ENABLE_THREADS
    LmoATANAs(df);
#else //ENABLE_THREADS
    LmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void SmoNEGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = -t;
*((S *)NUM_VAL(df)) = t;
}

   static void SmoNEGAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoNEGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = -t;
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoNEGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoNEGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoNEGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoNEGA(B *df)
  {
#if !ENABLE_THREADS
    SmoNEGAs(df);
#else //ENABLE_THREADS
    SmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void SmoABSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = fabs(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoABSAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoABSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = fabs(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoABSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoABSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoABSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoABSA(B *df)
  {
#if !ENABLE_THREADS
    SmoABSAs(df);
#else //ENABLE_THREADS
    SmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoSQRTS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sqrt(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoSQRTAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoSQRTAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = sqrt(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoSQRTAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoSQRTAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoSQRTAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoSQRTA(B *df)
  {
#if !ENABLE_THREADS
    SmoSQRTAs(df);
#else //ENABLE_THREADS
    SmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void SmoEXPS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = exp(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoEXPAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoEXPAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = exp(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoEXPAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoEXPAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoEXPAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoEXPA(B *df)
  {
#if !ENABLE_THREADS
    SmoEXPAs(df);
#else //ENABLE_THREADS
    SmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void SmoLNS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoLNAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoLNAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = log(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoLNAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoLNAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoLNAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoLNA(B *df)
  {
#if !ENABLE_THREADS
    SmoLNAs(df);
#else //ENABLE_THREADS
    SmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void SmoLGS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = log10(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoLGAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoLGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = log10(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoLGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoLGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoLGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoLGA(B *df)
  {
#if !ENABLE_THREADS
    SmoLGAs(df);
#else //ENABLE_THREADS
    SmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void SmoFLOORS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = floor(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoFLOORAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoFLOORAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = floor(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoFLOORAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoFLOORAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoFLOORAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoFLOORA(B *df)
  {
#if !ENABLE_THREADS
    SmoFLOORAs(df);
#else //ENABLE_THREADS
    SmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void SmoCEILS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = ceil(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoCEILAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoCEILAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = ceil(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoCEILAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoCEILAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoCEILAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoCEILA(B *df)
  {
#if !ENABLE_THREADS
    SmoCEILAs(df);
#else //ENABLE_THREADS
    SmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void SmoSINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = sin(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoSINAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoSINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = sin(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoSINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoSINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoSINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoSINA(B *df)
  {
#if !ENABLE_THREADS
    SmoSINAs(df);
#else //ENABLE_THREADS
    SmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void SmoCOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = cos(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoCOSAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoCOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = cos(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoCOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoCOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoCOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoCOSA(B *df)
  {
#if !ENABLE_THREADS
    SmoCOSAs(df);
#else //ENABLE_THREADS
    SmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoTANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = tan(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoTANAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoTANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = tan(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoTANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoTANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoTANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoTANA(B *df)
  {
#if !ENABLE_THREADS
    SmoTANAs(df);
#else //ENABLE_THREADS
    SmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void SmoASINS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = asin(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoASINAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoASINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = asin(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoASINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoASINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoASINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoASINA(B *df)
  {
#if !ENABLE_THREADS
    SmoASINAs(df);
#else //ENABLE_THREADS
    SmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void SmoACOSS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = acos(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoACOSAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoACOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = acos(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoACOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoACOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoACOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoACOSA(B *df)
  {
#if !ENABLE_THREADS
    SmoACOSAs(df);
#else //ENABLE_THREADS
    SmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void SmoATANS(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t = atan(t);
*((S *)NUM_VAL(df)) = t;
}

   static void SmoATANAs(B *df)
   {
     D t; S *d; L n;
     d = (S *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L SmoATANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; S * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((S *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((S *)d);
t = atan(t);
*((S *)d++) = t;
}
    return OK;
  }
    
  static void SmoATANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      SmoATANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, SmoATANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void SmoATANA(B *df)
  {
#if !ENABLE_THREADS
    SmoATANAs(df);
#else //ENABLE_THREADS
    SmoATANAc(df);
#endif //ENABLE_THREADS
  }

static void DmoNEGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = -t;
*((D *)NUM_VAL(df)) = t;
}

   static void DmoNEGAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoNEGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = -t;
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoNEGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoNEGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoNEGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoNEGA(B *df)
  {
#if !ENABLE_THREADS
    DmoNEGAs(df);
#else //ENABLE_THREADS
    DmoNEGAc(df);
#endif //ENABLE_THREADS
  }

static void DmoABSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = fabs(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoABSAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoABSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = fabs(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoABSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoABSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoABSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoABSA(B *df)
  {
#if !ENABLE_THREADS
    DmoABSAs(df);
#else //ENABLE_THREADS
    DmoABSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoSQRTS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sqrt(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoSQRTAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoSQRTAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = sqrt(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoSQRTAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoSQRTAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoSQRTAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoSQRTA(B *df)
  {
#if !ENABLE_THREADS
    DmoSQRTAs(df);
#else //ENABLE_THREADS
    DmoSQRTAc(df);
#endif //ENABLE_THREADS
  }

static void DmoEXPS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = exp(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoEXPAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoEXPAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = exp(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoEXPAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoEXPAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoEXPAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoEXPA(B *df)
  {
#if !ENABLE_THREADS
    DmoEXPAs(df);
#else //ENABLE_THREADS
    DmoEXPAc(df);
#endif //ENABLE_THREADS
  }

static void DmoLNS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoLNAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoLNAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = log(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoLNAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoLNAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoLNAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoLNA(B *df)
  {
#if !ENABLE_THREADS
    DmoLNAs(df);
#else //ENABLE_THREADS
    DmoLNAc(df);
#endif //ENABLE_THREADS
  }

static void DmoLGS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = log10(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoLGAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoLGAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = log10(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoLGAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoLGAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoLGAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoLGA(B *df)
  {
#if !ENABLE_THREADS
    DmoLGAs(df);
#else //ENABLE_THREADS
    DmoLGAc(df);
#endif //ENABLE_THREADS
  }

static void DmoFLOORS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = floor(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoFLOORAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoFLOORAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = floor(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoFLOORAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoFLOORAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoFLOORAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoFLOORA(B *df)
  {
#if !ENABLE_THREADS
    DmoFLOORAs(df);
#else //ENABLE_THREADS
    DmoFLOORAc(df);
#endif //ENABLE_THREADS
  }

static void DmoCEILS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = ceil(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoCEILAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoCEILAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = ceil(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoCEILAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoCEILAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoCEILAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoCEILA(B *df)
  {
#if !ENABLE_THREADS
    DmoCEILAs(df);
#else //ENABLE_THREADS
    DmoCEILAc(df);
#endif //ENABLE_THREADS
  }

static void DmoSINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = sin(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoSINAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoSINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = sin(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoSINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoSINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoSINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoSINA(B *df)
  {
#if !ENABLE_THREADS
    DmoSINAs(df);
#else //ENABLE_THREADS
    DmoSINAc(df);
#endif //ENABLE_THREADS
  }

static void DmoCOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = cos(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoCOSAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoCOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = cos(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoCOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoCOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoCOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoCOSA(B *df)
  {
#if !ENABLE_THREADS
    DmoCOSAs(df);
#else //ENABLE_THREADS
    DmoCOSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoTANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = tan(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoTANAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoTANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = tan(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoTANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoTANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoTANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoTANA(B *df)
  {
#if !ENABLE_THREADS
    DmoTANAs(df);
#else //ENABLE_THREADS
    DmoTANAc(df);
#endif //ENABLE_THREADS
  }

static void DmoASINS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = asin(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoASINAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoASINAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = asin(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoASINAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoASINAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoASINAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoASINA(B *df)
  {
#if !ENABLE_THREADS
    DmoASINAs(df);
#else //ENABLE_THREADS
    DmoASINAc(df);
#endif //ENABLE_THREADS
  }

static void DmoACOSS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = acos(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoACOSAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoACOSAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = acos(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoACOSAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoACOSAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoACOSAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoACOSA(B *df)
  {
#if !ENABLE_THREADS
    DmoACOSAs(df);
#else //ENABLE_THREADS
    DmoACOSAc(df);
#endif //ENABLE_THREADS
  }

static void DmoATANS(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t = atan(t);
*((D *)NUM_VAL(df)) = t;
}

   static void DmoATANAs(B *df)
   {
     D t; D *d; L n;
     d = (D *)VALUE_BASE(df);
for (n = (ARRAY_SIZE(df)>>3); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
for (n = (ARRAY_SIZE(df)&7); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
   }

#if ENABLE_THREADS
  static L DmoATANAt(UL id, B* indata)
  {
    thread_array_data* data = (thread_array_data*) indata;
    D t; L n, n_; D * s; D * d;
    n_ = data->perthread;
    if (thread_max == id) n_ += data->leftover;
    d = ((D *) data->df_start)+data->perthread*id;
for (n = (n_ >> 3); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
for (n = (n_ & 7); n>0; n--) {
t = *((D *)d);
t = atan(t);
*((D *)d++) = t;
}
    return OK;
  }
    
  static void DmoATANAc(B * df)
  {
    UL nways; thread_array_data data;
    if (thread_num == 1 || ARRAY_SIZE(df)/(THREADMUL*8) < 1)
      DmoATANAs(df);
    else {
      nways = ARRAY_SIZE(df)/(THREADMUL*8)
              + (ARRAY_SIZE(df)%(THREADMUL*8) ?
              1 : 0);
      if (nways > thread_num) nways = thread_num;
      data.df_start = VALUE_PTR(df);
      data.perthread = ARRAY_SIZE(df) / nways;
      data.leftover = ARRAY_SIZE(df) % nways;
      threads_do(nways, DmoATANAt, (B*) &data);
    }
  }
#endif //ENABLE_THREADS

  static void DmoATANA(B *df)
  {
#if !ENABLE_THREADS
    DmoATANAs(df);
#else //ENABLE_THREADS
    DmoATANAc(df);
#endif //ENABLE_THREADS
  }

typedef void (*monadic_fct)(B*);
static monadic_fct NEGlist[] = {
BmoNEGS, BmoNEGA, 
WmoNEGS, WmoNEGA, 
LmoNEGS, LmoNEGA, 
SmoNEGS, SmoNEGA, 
DmoNEGS, DmoNEGA, 

};
static monadic_fct ABSlist[] = {
BmoABSS, BmoABSA, 
WmoABSS, WmoABSA, 
LmoABSS, LmoABSA, 
SmoABSS, SmoABSA, 
DmoABSS, DmoABSA, 

};
static monadic_fct SQRTlist[] = {
BmoSQRTS, BmoSQRTA, 
WmoSQRTS, WmoSQRTA, 
LmoSQRTS, LmoSQRTA, 
SmoSQRTS, SmoSQRTA, 
DmoSQRTS, DmoSQRTA, 

};
static monadic_fct EXPlist[] = {
BmoEXPS, BmoEXPA, 
WmoEXPS, WmoEXPA, 
LmoEXPS, LmoEXPA, 
SmoEXPS, SmoEXPA, 
DmoEXPS, DmoEXPA, 

};
static monadic_fct LNlist[] = {
BmoLNS, BmoLNA, 
WmoLNS, WmoLNA, 
LmoLNS, LmoLNA, 
SmoLNS, SmoLNA, 
DmoLNS, DmoLNA, 

};
static monadic_fct LGlist[] = {
BmoLGS, BmoLGA, 
WmoLGS, WmoLGA, 
LmoLGS, LmoLGA, 
SmoLGS, SmoLGA, 
DmoLGS, DmoLGA, 

};
static monadic_fct FLOORlist[] = {
BmoFLOORS, BmoFLOORA, 
WmoFLOORS, WmoFLOORA, 
LmoFLOORS, LmoFLOORA, 
SmoFLOORS, SmoFLOORA, 
DmoFLOORS, DmoFLOORA, 

};
static monadic_fct CEILlist[] = {
BmoCEILS, BmoCEILA, 
WmoCEILS, WmoCEILA, 
LmoCEILS, LmoCEILA, 
SmoCEILS, SmoCEILA, 
DmoCEILS, DmoCEILA, 

};
static monadic_fct SINlist[] = {
BmoSINS, BmoSINA, 
WmoSINS, WmoSINA, 
LmoSINS, LmoSINA, 
SmoSINS, SmoSINA, 
DmoSINS, DmoSINA, 

};
static monadic_fct COSlist[] = {
BmoCOSS, BmoCOSA, 
WmoCOSS, WmoCOSA, 
LmoCOSS, LmoCOSA, 
SmoCOSS, SmoCOSA, 
DmoCOSS, DmoCOSA, 

};
static monadic_fct TANlist[] = {
BmoTANS, BmoTANA, 
WmoTANS, WmoTANA, 
LmoTANS, LmoTANA, 
SmoTANS, SmoTANA, 
DmoTANS, DmoTANA, 

};
static monadic_fct ASINlist[] = {
BmoASINS, BmoASINA, 
WmoASINS, WmoASINA, 
LmoASINS, LmoASINA, 
SmoASINS, SmoASINA, 
DmoASINS, DmoASINA, 

};
static monadic_fct ACOSlist[] = {
BmoACOSS, BmoACOSA, 
WmoACOSS, WmoACOSA, 
LmoACOSS, LmoACOSA, 
SmoACOSS, SmoACOSA, 
DmoACOSS, DmoACOSA, 

};
static monadic_fct ATANlist[] = {
BmoATANS, BmoATANA, 
WmoATANS, WmoATANA, 
LmoATANS, LmoATANA, 
SmoATANS, SmoATANA, 
DmoATANS, DmoATANA, 

};
static void Bdecr(B *df)
{
D t;
if ((t = *((B *)NUM_VAL(df))) == BINF) t = DINF;
t -= 1.0;
*((B *)NUM_VAL(df)) = (((t) > BMAX) || ((-t) < -BMAX) || (t == DINF))? BINF : t;
}

static void Wdecr(B *df)
{
D t;
if ((t = *((W *)NUM_VAL(df))) == WINF) t = DINF;
t -= 1.0;
*((W *)NUM_VAL(df)) = (((t) > WMAX) || ((-t) < -WMAX) || (t == DINF))? WINF : t;
}

static void Ldecr(B *df)
{
D t;
if ((t = *((L *)NUM_VAL(df))) == LINF) t = DINF;
t -= 1.0;
*((L *)NUM_VAL(df)) = (((t) > LMAX) || ((-t) < -LMAX) || (t == DINF))? LINF : t;
}

static void Sdecr(B *df)
{
D t;
t = *((S *)NUM_VAL(df));
t -= 1.0;
*((S *)NUM_VAL(df)) = t;
}

static void Ddecr(B *df)
{
D t;
t = *((D *)NUM_VAL(df));
t -= 1.0;
*((D *)NUM_VAL(df)) = t;
}

typedef void (*DECR_fct)(B*);
static DECR_fct DECRlist[] = {
Bdecr, Wdecr, Ldecr, Sdecr, Ddecr, 
};
