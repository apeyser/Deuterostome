
ÇhÄCHAPTER Å3Ç| mÄTHE OPERATORSÇ| 1 ls

ÇpÄThe D machine can be thought of as a group of shops that perform specific work 
Äon specific objects. The first part of this chapter describes each shop and Äsummarizes the shop's (operator) tools. It tells you what you can do in the shopÄ (and what you cannot), and discusses the intended roles of the tools. Last not Äleast, this part gives you a short reference for each operator, which usually isÄ all you need to support your memory. The second part of this chapter contains Äan operator lexicon, which describes each operator in detail.Ç| 1 lsÄ ÇcÅ3.1Ä ÅShops Åand ToolsÇ|

Çfontlist altfontlist exch /fontlist exch def /altfontlist exch def
ÇpÄIn  the operator tables given below,  items appearing on the left of  the 
Äoperator  name (which is in ÅboldÄ) represent the operands and the order  in 
Äwhich these are expected on the stack (the last operand is the topmost  on 
Äthe stack).  Conversely,  the items on the right of the operator name  are 
Äthe results deposited on the stack (again,  the last item is the topmost). 
ÄThese stack objects are indicated by their class or type, or by names that 
Äsuggest their intended content;  a '/' separates alternative objects,  and 
Ä'//' separates alternative object sets.Ç|
Çfontlist altfontlist exch /fontlist exch def /altfontlist exch def

ÇpÄThe  intrinsic  operators  are  associated  with  names  in  the   system 
Ädictionary.  This dictionary is set up during the self-inititialization of 
Äthe  D  machine  andÄ isÄ placed Äpermanently Äat the bottom  of  the  dictionary 
Ästack.Ç| 1 ls

Çtogglefonts
Ç/tabs [ [100 2] [12 1] [80 1] [textwidth 182 sub 1] ] def

ÇcÄOÖPERAND STACK MANIPULATION OPERATORSÇ| 1 ls 

ÇnÄ                   anyÇ| tÄ Ç| tÅpopÇ| tÄ--Ç|
ÇnÅ             Äany†1Ä any†2Ç| tÄ Ç| tÅexchÇ| tÄany†2Ä any†1Ç|
ÇnÅ                   ÄanyÇ| tÄ Ç| tÅdupÇ| tÄany anyÇ|
ÇnÅ          Äany†1Ä..any†nÄ nÇ| tÄ Ç| tÅcopyÇ| tÄany†1Ä..any†nÄ any†1Ä..any†nÇ|
ÇnÅ          Äany†nÄ..any†0Ä nÇ| tÄ Ç| tÅindexÇ| tÄany†nÄ..any†0Ä any†nÇ|
ÇnÅ    Ä      a†n-1Ä..a†0Ä n jÇ| tÄ Ç| tÅrollÇ| tÄa†(j-1)Ä †modÄ †nÄ..a†0Ä a†n-1Ä..a†jÄ †modÄ †nÇ|
ÇnÅ          Ä| any†1Ä..any†nÇ| tÄ Ç| tÅclearÇ| tÄ--Ç|
ÇnÅ          Ä  any†1Ä..any†nÇ| tÄ Ç| tÅcountÇ| tÄany†1Ä..any†nÄ nÇ|
ÇnÅ                    Ä--Ç| tÄ Ç| tÅ[Ç| tÄmarkÇ|
ÇnÄ          [ obj†1Ä..obj†nÇ| tÄ Ç| tÅ]Ç| tÄlistÇ| 
ÇnÅ       Ä   [ obj†1Ä..obj†nÇ| tÄ Ç| tÅcleartomarkÇ| tÄ--Ç|
ÇnÅ       Ä   [ obj†1Ä..obj†nÇ| tÄ Ç| tÅcounttomarkÇ| tÄmark obj†1Ä..obj†nÄ nÇ|
ÇnÄ                    --Ç| tÄ Ç| tÅnullÇ| tÄnullÇ|
ÇnÄ                    --Ç| tÄ Ç| tÅtrueÇ| tÄtrueÇ|
ÇnÄ                    --Ç| tÄ Ç| tÅfalseÇ| tÄfalseÇ|
Çtogglefonts


ÇpÄExplicit manipulation of stack objects becomes necessary,  for  instance, 
Äwhen  the  results  left on the stack by one operator  do  not  match  the 
Äoperand  requirements of a subsequent operator.  Simple  stack  operations 
Äremove (ÑpopÄ),  exchange (ÑexchÄ), or duplicate (ÑdupÄ) the top elements of the 
Ästack.  Others  duplicate  portions  of the  stack  (ÑcopyÄ),  rotate  stack 
Äelements  in a chain (ÑrollÄ),  or access the stack like an indexable  array 
Ä(ÑindexÄ). The operand stack is cleared (ÑclearÄ), or its elements are counted 
Ä(ÑcountÄ).Ç|

ÇpÄThere are facilities to mark a position on the stack ([) and to count  or 
Ädelete the elements following the latest mark (ÑcounttomarkÄ,  ÑcleartomarkÄ). 
ÄThese  operators serve mainly in the assembly of lists on the  stack  (see 
Äbelow).Ç|

ÇpÄSince  there  is no text representation of the null  or  boolean  objects, 
Äoperators are provided to create these objects on the stack  (ÑnullÄ,  ÑtrueÄ, 
ÑfalseÄ).Ç| 1 ls

Çtogglefonts
ÇcÄMÖATHEMATICAL OPERATORSÇ|

ÇcÖMONADICÇ| 
ÇnÄ             num/arrayÇ| tÄ Ç| tÅabsÇ| tÄabsolute valueÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅnegÇ| tÄnegated valueÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅsqrtÇ| tÄsquare rootÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅcosÇ| tÄcosineÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅacosÇ| tÄarccosineÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅsinÇ| tÄsineÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅasinÇ| tÄarcsineÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅtanÇ| tÄtangentÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅatanÇ| tÄarctangentÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅexpÇ| tÄexponential (base e)Ç|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅlnÇ| tÄlogarithm (base e)Ç|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅlgÇ| tÄlogarithm (base 10)Ç|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅfloorÇ| tÄround down to integerÇ|
ÇnÄ             num/arrayÇ| tÄ Ç| tÅceilÇ| tÄround up to integerÇ|

ÇcÖDYADICÇ|
ÇnÄ             num†aÄ num†bÇ|
ÇnÄ         / array†aÄ num†bÇ|
ÇnÄ     †  Ä  / num†aÄ array†bÇ|
ÇnÄ       / array†aÄ array†bÇ| tÄ Ç| tÅaddÇ| tÄsumÇ|
ÇnÄ                   ..Ç | tÄ Ç| tÅsubÇ| tÄdifference (a - b)Ç|
ÇnÄ                   ..Ç | tÄ Ç| tÅmulÇ| tÄproductÇ|
ÇnÄ                   ..Ç | tÄ Ç| tÅdivÇ| tÄquotient (a / b)Ç|
ÇnÄ                   ..Ç | tÄ Ç| tÅpwrÇ| tÄpower (aêbÄ)Ç|Ä Ç1 ls


Çtogglefonts
ÇpÄThe monadic operators take one operand. When given a numeral (scalar), they 
Äreturn a scalar. When given an array, they operate on all elements of the array,Ä replace them with the results, and return the modified array. The dyadic Äoperators take a pair of operands. With two scalar operands, they return a Äscalar result. With a pivotal scalar operand and a second array operand, they Ärepeat the operation with each array element as the second operand and the Äscalar as the first operand; the scalar value is replaced by the running  Äresult.Ä ÄIn the converse operand configuration, a pivotal array and a second Äscalar operand, the operation is performed on each array element as the first Äoperand always using the scalar as the second operand; the results overwrite theÄ original array elements. With two arrays as operands, the operation is Äperformed with the corresponding elements (array dimensions need to be matched) Äand the results overwrite the pivotal array.Ç|

ÇpÄAll mathemetical operators first convert their operands into the 
Ädouble-precision floating point (IEEE) format, then perform the operation, and Äfinally convert the result back into the type of the (first) operand. All Äoperators work with all numeral types for first or second second operands. Note Äthat by this convention the type of the first operand in a dyadic operation Ädetermines the type of the result, but the operation itself is performed in the Ä/D type.Ç|

ÇpÄThe   mathematical   operators  accept  ÑundefinedÄ  operand   values   and 
Äautomatically propagate ÑundefinedÄ into the result values. If the 
Äoperation itself fails to yield a valid result,  it also returns ÑundefinedÄ. No Äerror is indicated when mathematical operators receive or generate ÑundefinedÄ Ävalues, but other operators will generally reject ÑundefinedÄ operand values.Ä ÄThe Ñundefined Ävalues of integers are expressed by the largest negative value of Ätheir ranges (e.g. -128 for /B). For real types ÑundefinedÄ values comprise all ÄINF and NAN patterns of the IEEE floating point standard; the '*' notation for Äexpressing undefined numeral values always generates +INF. You can test whether Äa /S or /D type numeral is ÑundefinedÄ by comparing it with the ÑeqÄ or ÑneÄ operator Äagainst '*'; both operators consider all possible INF and NAN patterns in this Ätest as equal to '*' (+INF).Ç|
Ç 
ÇpÄThe mathematical operators work only with ÑinternalÄ objects.Ç| 1 ls

Çtogglefonts
ÇcÄOÖPERATORS FOR COMPOSITE OBJECTSÇ|
Çtogglefonts

ÇpÄEach species of composite object is created by a specific  operator,  and 
Äthere  are  separate operators to create a particular class of  object  in 
Äinternal or external VM.  Ñarray,  list,Ä  ],Ñ dictÄ, and ÑsaveÄ create internal Äcomposite 
Äobjects,  whereas Ñearray,  elist, edictÄ,andÑ toboxÄ create external objects. 
ÄThey are the only operators that actually allocate VM or eVM  memory.  All 
Äother composite object operators work within objects previously allocated. 
ÄCompetences  were  divided  in this way to facilitate  control  of  memory 
Äresources. ÑearrayÄ,Ä ÑelistÄ,Ä ÑedictÄ, and ÑtoboxÄ can create their objects either 
Äin the permanent or the temporary part of an eVM; they are directed by the 
Äsign given to the eVM identifier operand (positive:  temporary;  negative: 
Äpermanent).  When  composite objects are created in VM or eVM,  memory  is 
Äreserved  for  both  the value and a master copy of  the  description  (in 
Äaddition  to  the  description  returned  on  the  stack);   these  master 
Ädescriptions  provide  a backup path of access to VM or  eVM  values:  the 
ÑnextobjectÄ  operator  uses this path to sequentially retrieve  VM  or  eVM 
Äobjects (see below).  eVM objects also receive a stamp that marks the time 
Äand date of their creation;  this stamp can be read by the ÑvalidÄ operator. 
ÄFinally,  (temporary) eVM resources can be reclaimed by deleting objects createdÄ after a certain mark object (ÑdiscardÄ).Ç|

ÇpÄSeveral  operators  perform  analogous  tasks  on  composite  objects  of 
Äseveral classes. They inquire the dimension of the object (ÑlengthÄ), access 
Äor replace individual elements (ÑgetÄ, ÑputÄ), physically copy the elements of 
Äthe object valu to another object (ÑcopyÄ),  or present the elements of  the 
Ävalue successively to a procedure, which is invoked once for every element 
Ä(ÑforallÄ).  Arrays  or  lists  (but  not  dictionaries)  may  be  logically 
Äsubdivided into subarrays or sublists (ÑgetintervalÄ). Subarrays or sublists 
Äphysically  share their elements with their parents and  siblings;  hence, 
Ächanges  made  to  one  member of the object  family  affect  others  that 
Ärepresent  concerned elements of the value.  Some of these operators  work 
Äwith both internal and external objects.Ç| 
ÇpÄThe following operators deal with arrays:Ç| 1 ls

Çtogglefonts
ÇnÄ                  n typeÇ| tÄ Ç| tÅarrayÇ| tÄarrayÇ|
ÇnÄ            eVMid n typeÇ| tÄ Ç| tÅearrayÇ| tÄarrayÇ|
ÇnÄ                   arrayÇ| tÄ Ç| tÅexternalÇ| tÄeVMid true // falseÇ|
ÇnÄ                   arrayÇ| tÄ Ç| tÅvalidÇ| tÄstamp (or error)Ç|
ÇnÄ                   arrayÇ| tÄ Ç| tÅlengthÇ| tÄnÇ|
ÇnÄ             array indexÇ| tÄ Ç| tÅgetÇ| tÄnumÇ|
ÇnÄ         num array indexÇ| tÄ Ç| tÅputÇ| tÄ--Ç|
ÇnÄ           array index nÇ| tÄ Ç| tÅgetintervalÇ| tÄsubarrayÇ|
ÇnÄ      array†1Ä/num†1 Äarray†2Ç| tÄ Ç| tÅcopyÇ| tÄarray†2Ç|
ÇnÄ    array†1Ä index†1Ä array†2Ç| tÄ Ç| tÅfaxÇ| tÄarray†1Ä index†2Ç|
ÇnÄ              array procÇ| tÄ Ç| tÅforallÇ| tÄ--Ç|
ÇnÄ            array n typeÇ| tÄ Ç| tÅparcelÇ| tÄsubarray†2Ä subarray†1Ç|
ÇnÄ             string seekÇ| tÄ Ç| tÅanchorsearchÇ| tÄpost match trueÇ|
ÇnÄ                        Ç| tÄ Ç| tÄ            Ç| tÄor string falseÇ|
ÇnÄ             string seekÇ| tÄ Ç| tÅsearchÇ| tÄpost match pre trueÇ|
ÇnÄ                        Ç| tÄ Ç| tÄ      Ç| tÄor string falseÇ|
ÇnÄ                  stringÇ| tÄ Ç| tÅtokenÇ| tÄpost obj trueÇ|
ÇnÄ                        Ç| tÄ Ç| tÄ     Ç| tÄor string falseÇ|
ÇnÄ         eVM_obj / eVMidÇ| tÄ Ç| tÅdiscardÇ| tÄ--Ç|
Çtogglefonts

ÇpÑparcel Äis specific for arrays;  it subdivides an array into subarrays  of 
Äarbitrary  numeral  type  and thus facilitates multiple  uses  of  arrays. 
ÑparcelÄ  works  with both internal and external arrays.Ñ  copyÄ  moves  array 
Äelements  between  length-matched ÑinternalÄ arrays and  performs  automatic 
Änumeral  type conversions on the transferred elements.  ÑfaxÄ  copies  array 
Äelements  between  any  combination of ÑinternalÄ  or Ñ  externalÄ  arrays  of 
Ämatching numeral types.Ç|Ä 

ÇpÑInternalÄ  arrays  also participate in mathematical  operations  described 
Äseparately.Ç|

ÇpÄOther array operators specialize in strings (byte arrays).  Two of  these 
Ädissect  a string after seeking for a pattern that defines the  breakpoint 
Ä(ÑsearchÄ,  ÑanchorsearchÄ).  The  third operator (ÑtokenÄ) translates a  string 
Äaccording  to  the D syntax rules until a complete (simple  or  enumerated 
Äcomposite)  object  has been assembled,  and returns that object  and  the 
Äuntranslated remainder of the string. These operators use internal strings 
Äonly.Ç|

ÇpÄNote  the following constraints when working with external  byte  arrays: 
ÑgetintervalÄ  or ÑparcelÄ accept only even indices and sizes when applied  to 
ÑexternalÄ  byte  arrays (no such restriction applies to internal  or  other 
Ätypes  of  external  arrays).  Ñearray Äaccepts only  even  sizes  for  byte 
Äarrays. ÑfaxÄ accepts only even indices and lengths when working with (internal orÄ external) byte arrays.Ç| 

ÇpÄThe following operators deal with list objects:Ç| 1 ls

Çtogglefonts
ÇnÄ                       nÇ| tÄ Ç| tÅlistÇ| tÄlistÇ|
ÇnÄ                 eVMid nÇ| tÄ Ç| tÅelistÇ| tÄlistÇ|
ÇnÄ                    listÇ| tÄ Ç| tÅexternalÇ| tÄeVMid true // falseÇ|
ÇnÄ                    listÇ| tÄ Ç| tÅvalidÇ| tÄstamp (or error)Ç|
ÇnÄ                      --Ç| tÄ Ç| tÅ[Ç| tÄmarkÇ|
ÇnÄ         mark obj†0Ä..obj†nÇ| tÄ Ç| tÅ]Ç| tÄlistÇ|
ÇnÄ              list indexÇ| tÄ Ç| tÅgetÇ| tÄobjÇ|
ÇnÄ          obj list indexÇ| tÄ Ç| tÅputÇ| tÄ--Ç|
ÇnÄ            list index nÇ| tÄ Ç| tÅgetintervalÇ| tÄsublistÇ|
ÇnÄ             list†1Ä list†2Ç| tÄ Ç| tÅcopyÇ| tÄlist†2Ç|
ÇnÄ      list†1Ä index†1Ä list†2Ç| tÄ Ç| tÅfaxÇ| tÄlist†1Ä index†2Ç|
ÇnÄ               list procÇ| tÄ Ç| tÅforallÇ| tÄ--Ç|
ÇnÄ              list eVMidÇ| tÄ Ç| tÅtoboxÇ| tÄboxÇ|
ÇnÄ                     boxÇ| tÄ Ç| tÅfromboxÇ| tÄlistÇ|
Çtogglefonts

ÇpÄThe square bracket operators,  [], serve to construct a list, element for 
Äelement,  on the operand stack.  First,  a mark object is layed down  ([). 
ÄSubsequent  activity  produces  objects  that  accumulate  on  the   stack 
Äfollowing the mark.  Finally,  by the ']' operator, a list of matched size 
Äis created, all objects following the mark are transferred into the list's 
Äbody,  and  the stack objects including the mark are replaced by the  list 
Äobject.  Note  that the similarity with array or procedure enumeration  is 
Äsuperficial:  objects between [] are ÑexecutedÄ like any other objects (they 
Äare not included literally into the body of the list).Ç|

ÇpÄA  list  can give origin to an object tree,  which in the  simplest  case 
Äcomprises the value of the root list itself. If elements of the root value 
Äare internal composite objects themselves,  also their values are part  of 
Äthe tree.  Of the elements of these values, internal lists or dictionaries Äcontinue the  tree (as new nodes), whereas external  lists or dictionaries do Änot (they are considered leafs).  ÑtoboxÄ assembles,  in a temporary VM buffer, a Äcompact 
Äcopy  of  the values of all internal composite objects that  constitute  a 
Ätree  and  saves the compact copy into one external  box  object.  ÑfromboxÄ 
Äretrieves that tree into VM,  again in one operation.  Objects belonging to the Ätree cannot 
Äbe  accessed individually while in the box.  These operators  thus 
Äallow you to move large,  logically connected collections of objects in  a 
Äconvenient and physically efficient manner.Ç|


ÇpÄThe following operators deal with dictionaries:Ç| 1 ls

Çtogglefonts
ÇnÄ                       nÇ| tÄ Ç| tÅdictÇ| tÄdictÇ|
ÇnÄ                 eVMid nÇ| tÄ Ç| tÅedictÇ| tÄdictÇ|
ÇnÄ                    dictÇ| tÄ Ç| tÅexternalÇ| tÄeVMid true // falseÇ|
ÇnÄ                    dictÇ| tÄ Ç| tÅvalidÇ| tÄstamp (or error)Ç|
ÇnÄ                    dictÇ| tÄ Ç| tÅlengthÇ| tÄnumÇ|
ÇnÄ                    dictÇ| tÄ Ç| tÅusedÇ| tÄnumÇ|
ÇnÄ                    dictÇ| tÄ Ç| tÅbeginÇ| tÄ--Ç|
ÇnÄ                      --Ç| tÄ Ç| tÅendÇ| tÄ--Ç|
ÇnÄ               /name objÇ| tÄ Ç| tÅdefÇ| tÄ--Ç|
ÇnÄ               obj /nameÇ| tÄ Ç| tÅnameÇ| tÄ--Ç|
ÇnÄ              dict /nameÇ| tÄ Ç| tÅgetÇ| tÄobjÇ|
ÇnÄ          obj dict /nameÇ| tÄ Ç| tÅputÇ| tÄ--Ç|
ÇnÄ              dict /nameÇ| tÄ Ç| tÅknownÇ| tÄboolÇ|
ÇnÄ                   /nameÇ| tÄ Ç| tÅfindÇ| tÄobjÇ|
ÇnÄ             dict†1Ä dict†2Ç| tÄ Ç| tÅmergeÇ| tÄdict†1Ç|
ÇnÄ               dict procÇ| tÄ Ç| tÅforallÇ| tÄ--Ç|
ÇnÄ                      --Ç| tÄ Ç| tÅsystemdictÇ| tÄdictÇ|
ÇnÄ                      --Ç| tÄ Ç| tÅuserdictÇ| tÄdictÇ|
ÇnÄ                      --Ç| tÄ Ç| tÅcurrentdictÇ| tÄdictÇ|
ÇnÄ                      --Ç| tÄ Ç| tÅcountdictstackÇ| tÄnumÇ|
ÇnÄ                   arrayÇ| tÄ Ç| tÅdictstackÇ| tÄsubarrayÇ|
ÇnÄ              dict eVMidÇ| tÄ Ç| tÅtoboxÇ| tÄboxÇ|
ÇnÄ                     boxÇ| tÄ Ç| tÅfromboxÇ| tÅdictÇ|
Çtogglefonts

ÇpÄThe  total capacity (ÑlengthÄ) or used capacity (ÑusedÄ) of a dictionary  may 
Äbe inquired (as the number of association pairs).  Other operators move  a 
Ädictionary  to  and from the dictionary stack (ÑbeginÄ,  ÑendÄ)  in  order  to 
Äcontrol  the lexical scope of name searches (internal dictionaries  only). 
ÄName-object associations are formed in the current dictionary (ÑdefÄ,  ÑnameÄ) 
Äor  in  any  ÑinternalÄ dictionary  explicitely  specified  (ÑputÄ).  You  can 
Ädetermine  whether  or  not a name is defined  in  a  particular  Ñinternal 
Ädictionary (ÑknownÄ) and/or retrieve the associated object (ÑgetÄ). All active 
Ädictionaries (i.e. those present on the dictionary stack) are searched for 
Äan  association  by ÑfindÄ.  The associations in one  internal  or  external 
Ädictionary are merged into another internal or external dictionary (ÑmergeÄ, as  Äby repeated ÑdefÄ operations).  ÑtoboxÄ and ÑfromboxÄ (see list  operators,  above) 
Äalso work with a dictionary as their root object.Ç|

ÇpÄTwo  dictionaries  always  present  on  the  dictionary  stack  and   the 
Ädictionary   currently   on  top  of  the  stack  are   accessed   through 
Äassociated  names  (ÑsystemdictÄ,  ÑuserdictÄ,  ÑcurrentdictÄ).  The  number  of 
Ädictionaries present on the stack is inquired through ÑcountdictstackÄ,  and 
Äthe  current contents of the dictionary stack are copied into a  list  for 
Ädiagnostic purposes by ÑdictstackÄ.Ç|

ÇpÄBox  objects  in external VMs are dealt  with  by  the 
Äfollowing operators:Ç| 1 ls

Çtogglefonts
ÇnÄ         list/dict eVMidÇ| tÄ Ç| tÅtoboxÇ| tÄboxÇ|
ÇnÄ                     boxÇ| tÄ Ç| tÅfromboxÇ| tÄrootlist/rootdictÇ|
Çn                     ÄboxÇ| tÄ Ç| tÅexternalÇ| tÄeVMid true // falseÇ|
ÇnÄ                     boxÇ| tÄ Ç| tÅvalidÇ| tÄstamp (or error)Ç|
ÇnÄ                     boxÇ| tÄ Ç| tÅlengthÇ| tÄn (bytes)Ç|

ÄÇtogglefonts

ÇpÄBox objects in internal VM serve a purpose that differs from that of external 
Äboxes. Internal boxes are created by the ÑsaveÄ, and consumed by the ÑrestoreÄ, Äoperators described under 'VM Operators' below. These boxes contain Äinformation on VM subranges and hold stack images, which are used in VM and Ästack management.Ç| 2 ls

Çtogglefonts
ÇcÄRÖELATIONAL, BOOLEAN, AND BITWISE OPERATORSÇ| 1 ls

ÇnÄ            any†1Ä any†2Ç| tÄ Ç| tÅeqÇ| tÄboolÇ|
ÇnÄ            any†1Ä any†2Ç| tÄ Ç| tÅneÇ| tÄboolÇ|
ÇnÄ            num†1Ä num†2Ç| tÄ Ç| tÅgeÇ| tÄboolÇ|
ÇnÄ            num†1Ä num†2Ç| tÄ Ç| tÅgtÇ| tÄboolÇ|
ÇnÄ            num†1Ä num†2Ç| tÄ Ç| tÅleÇ| tÄboolÇ|
ÇnÄ            num†1Ä num†2Ç| tÄ Ç| tÅltÇ| tÄboolÇ|
ÇnÄbool†1Ä/num†1Ä bool†2Ä/num†2Ç| tÄ Ç| tÅandÇ| tÄbool/numÇ|
ÇnÄbool†1Ä/num†1Ä bool†2Ä/num†2Ç| tÄ Ç| tÅorÇ| tÄbool/numÇ|
ÇnÄbool†1Ä/num†1Ä bool†2Ä/num†2Ç| tÄ Ç| tÅxorÇ| tÄbool/numÇ|
ÇnÄ             bool/numÇ| tÄ Ç| tÅnotÇ| tÄbool numÇ|
ÇnÄ                   --Ç| tÄ Ç| tÅtrueÇ| tÄtrueÇ|
ÇnÄ                   --Ç| tÄ Ç| tÅfalseÇ| tÄfalseÇ|
ÇnÄ            num shiftÇ| tÄ Ç| tÅbitshiftÇ| tÄnumÇ|
Çtogglefonts

ÇpÄThe  relational  operators  compare two operands  and  return  a  boolean 
Äindicating whether or not the relation holds.  Any two objects of matching 
Äclass are tested for equality (ÑeqÄ, ÑneÄ) of their values (simple objects) or 
Äidentity of their values (composite objects). Only numerals are tested for 
Äthe other relations (Ñge,  gt,  le, ltÄ). ÑeqÄ and ÑneÄ accept numerals of value 
Ä'undefined', so they can test for the occurrence of this value.Ç|

ÇpÄLogical operations (ÑandÄ,  ÑorÄ,  ÑxorÄ,  ÑnotÄ) use booleans (then returning  a 
Äboolean) or work in a bitwise fashion on numerals (then returning a numeral). ÄThe internal representation of numeral values normally remains transparent, but Ähere it is important for understanding the bitwise logical operations. These Äoperators are intended to be used on integers, which are 8-, 16-, or 32-bit Ätwo's complement numbers; the 'undefined' bit pattern is treated as a valid Äpattern (sign bit set, other bits reset). Real types are also accepted, but the Äinterpretation of their results requires detailed knowledge of the IEEE Äfloating-point formats. If two equal types are used in a binary logical Äoperation, this operation is performed on all bits in parallel and the result isÄ meaningful in all positions. If the second operand, however, is shorter than Äthe first, the operands are aligned with respect to their least-significant bitsÄ and the shorter operand is expanded with zeroes. The operation is performed Äover the width of the first (longer) operand.Ç|

ÇpÄThese operators require internal objects for operands.Ç| 1 ls

Çtogglefonts
ÇcÄCÖONTROL OPERATORSÇ| 1 ls

ÇnÑ                    ÄanyÇ| tÄ Ç| tÅexecÇ| tÄ--Ç|
ÇnÄ                    anyÇ| tÄ Ç| tÅstartÇ| tÄ--Ç|
ÇnÄ              bool procÇ| tÄ Ç| tÅifÇ| tÄ--Ç|
ÇnÄ       bool proc†1Ä proc†2Ç| tÄ Ç| tÅifelseÇ| tÄ--Ç|
ÇnÄ   init incr limit procÇ| tÄ Ç| tÅforÇ| tÄ--Ç|
ÇnÄ             count procÇ| tÄ Ç| tÅrepeatÇ| tÄ--Ç|
ÇnÄ                   procÇ| tÄ Ç| tÅloopÇ| tÄ--Ç|
ÇnÄ   array/list/dict procÇ| tÄ Ç| tÅforallÇ| tÄ--Ç|
ÇnÄ                     --Ç| tÄ Ç| tÅexitÇ| tÄ--Ç|
ÇnÄ                     --Ç| tÄ Ç| tÅstopÇ| tÄ--Ç|
ÇnÄ                    anyÇ| tÄ Ç| tÅstoppedÇ| tÄboolÇ|
ÇnÄ                     --Ç| tÄ Ç| tÅhaltÇ| tÄ--Ç|
ÇnÄ                     --Ç| tÄ Ç| tÅcontinueÇ| tÄ--Ç|
ÇnÄ             string numÇ| tÄ Ç| tÅerrorÇ| tÄ--Ç|
ÇnÄ                     --Ç| tÄ Ç| tÅabortÇ| tÄ--Ç|
ÇnÄ                     --Ç| tÄ Ç| tÅcountexecstackÇ| tÄnumÇ|
ÇnÄ                   listÇ| tÄ Ç| tÅexecstackÇ| tÄsublistÇ|
ÇnÄ                     --Ç| tÄ Ç| tÅquitÇ| tÄ--Ç|
Çtogglefonts

ÇpÄControl operators modify the usual sequential  execution  of 
Äobjects,  often working with a procedure operand that they execute conditionallyÄ 
Äor repeatedly. In addition to the control operators listed in this section, someÄ operators for the Virtual Terminal and other ports also can schedule proceduresÄ for execution; these operators are described separately.Ç|

ÇpÄAny  object  carrying the ÑactiveÄ attribute is pushed onto  the  execution 
Ästack for immediate execution by ÑexecÄ;  ÑstartÄ is analogous, but first pops 
Äthe  current  top object from the execution stack (it thus  swaps  control 
Äfrom  one currently executed object to another).  A procedure is  executed 
Äconditionally,  dependent on the value of a boolean operand (ÑifÄ,  ÑifelseÄ). 
ÄSeveral  operators execute a procedure operand  repeatedly  (ÑforÄ,  ÑrepeatÄ, 
ÑloopÄ,  ÑforallÄ);  the ÑexitÄ operator terminates the execution of the current 
Ä(innermost) loop.Ç|

ÇpÑstoppedÄ executes an object (usually a procedure) 
Äwith a provision for two alternate kinds of termination, normal or stopped.  ÄStopped termination  (effected  by  the ÑstopÄ operator  executed from  within  Äthe 
Ädynamic context of the object) returns a ÑtrueÄ, normal termination, a ÑfalseÄ 
Äboolean, and continues execution with the object immediately following the 
Ñstopped Äoperator. This construct helps  prepare  contexts that terminate on  Äexceptional events and turn control over to a supervisory context. The Äexceptional termination removes from the execution stack all objects that belongÄ to the stopped context (such as pending procedures and loops in execution); it Äprovides a clean exit from a domain of structured code, which would not be Äpossible with a 'goto' operator. The loop termination operator, ÑexitÄ, cannot Ämove control outside the context of a ÑstoppedÄ operator (the attempt produces an Äerror).Ç|

ÇpÄWhenever a component of the D machine detects an error condition, it initiates 
Äa uniform error response: a string (revealing the instance of discovery, like Äthe operator name) and a numeral (coding for the type of the error) are pushed Äon the operand stack, and the active name 'error' is executed. 'error' is by Ädefault associated with the ÑerrorÄ operator, which proceeds as follows. The Ästring and numeral on the operand stack are consumed to formulate a console Äerror message; after showing this message, the ÑhaltÖ Äoperator is executed. ÑhaltÄ Ähas two effects: (1) it pushes a copy of itself on the execution stack and (2) Äit directs the mill to submit phrases entered to the console screen to Äexecution. Thus you can interact with the D machine, e.g. to inspect stack and Äobject contents related to the error while the context that produced the error Äis suspended. If you can fix the error from the console, you may choose to Äexecute Ñcontinue. continueÄ drops the execution stack below the topmost ÑhaltÄ Äobject and thus resumes execution of the context suspended by that ÑhaltÄ. ÄAlternatively, if you consider the problem fatal, you may terminate the flawed Äcontext by executingÑ stop Ä(if you have set up a capsule with ÑstoppedÄ) or Ñabort.Ä Ñabort Ädrops all stacks to their floors (which in case 
Äof the dictionary stack still leaves ÑsystemdictÄ and ÑuserdictÄ, which are Äpermanent). This cancels all activities of the D machine and prepares the Ämachine to execute console phrases.Ç|

ÇpÄThis method of responding to errors can be modified by redefining, e.g., 
Ä'error' as a procedure that automatically handles certain situations and resortsÄ to the operator Ñerror Äonly in cases that need operator attention. You can Äembark on the standard error mechanism by using the ÑerrorÄ operator explicitely Äwithin your own procedures when you want to signal a problem incurred by the Äprogram.Ç| 1 ls
Çtogglefonts
ÇcÄTÖYPE, ATTRIBUTE, AND CONVERSION OPERATORSÇ| 1 ls

ÇnÄ                    anyÇ| tÄ Ç| tÅclassÇ| tÄ/classÇ|
ÇnÄ              num/arrayÇ| tÄ Ç| tÅtypeÇ| tÄ/typeÇ|
ÇnÄ                    anyÇ| tÄ Ç| tÅreadonlyÇ| tÄboolÇ|
ÇnÄ                    anyÇ| tÄ Ç| tÅactiveÇ| tÄboolÇ|
Çn                    ÄanyÇ| tÄ Ç| tÅexternalÇ| tÄeVMid true / falseÇ|
ÇnÄ                    anyÇ| tÄ Ç| tÅparentÇ| tÄboolÇ|
ÇnÄ                    anyÇ| tÄ Ç| tÅmkreadÇ| tÄanyÇ|
ÇnÄ                    anyÇ| tÄ Ç| tÅmkactÇ| tÄanyÇ|
ÇnÄ                    anyÇ| tÄ Ç| tÅmkpassÇ| tÄanyÇ|
ÇnÄ        num/array /typeÇ| tÄ Ç| tÅctypeÇ| tÄnum/arrayÇ|
ÇnÄ          array n /typeÇ| tÄ Ç| tÅparcelÇ| tÄrest_of_array new_arrayÇ|
ÇnÄ         strb idx w objÇ| tÄ Ç| tÅtextÇ| tÄstrb idxÇ|
ÇnÄ strb idxÑ Äw num frmÇ| tÄ Ç| tÅnumberÇ| tÄstrb idx
ÇnÄ                 stringÇ| tÄ Ç| tÅtokenÇ| tÄsubstring obj trueÇ|
ÇnÄ                       Ç| tÄ Ç| tÄ     Ç| tÄor string falseÇ|
ÇnÄ                   procÇ| tÄ Ç| tÅbindÇ| tÄprocÇ|
Çtogglefonts

ÇpÄThe  class,  numeral type,  and attributes of an object can be  inquired. 
ÑclassÄ  or  ÑtypeÄ  return passive names such as  '/nameclass'  or  '/B'  (an 
Äexample of using such names to program class- or type-dependent processing 
Äis given in the Operator Lexicon, under ÑclassÄ). The storage location of an 
Äobject  can  be  determined  by ÑexternalÄ,  and  its  other  attributes  by 
ÑreadonlyÄ,  ÑactiveÄ,  orÑ parentÄ.  ÑmkreadÄ, ÑmkactÄ, ÑmkpassÄ change an attribute; 
Äthe ÑreadonlyÄ attribute cannot be reversed once established.Ç|

ÇpÄThe  type  of  a  numeral or array is converted  into  a  different  type 
Ä(ÑctypeÄ),  and an array of any type is parcelled into subarrays of the same 
Äor other typeÑ (parcelÄ).  Type conversion of a numeral object converts  the 
Ätype  specification  of the object and translates the value into  the  new 
Äbinary representation.  Type conversions involving arrays change only  the 
Ätype  specification in the object description,  but do not  translate  the 
Ävalue from the old to the new binary representation  (hence,  pre-existing 
Ävalues of such arrays generally become uninterpretable).Ç|

ÇpÄA  string  is assembled from smaller strings or text  representations  of 
Äother  objects (ÑtextÄ,  ÑnumberÄ).  These operators provide fine  control  of 
Äformats  and  thus are universal tools of text composition. ÑtextÄ can render Äseveral kinds of object (ÑobjÄ): string, name, operator, or numeral (used as ASCIIÄ code of one character). Conversely, a string  is translated into D objects byÄ ÑtokenÄ.Ç|

ÇpÄSubjecting  a procedure to the ÑbindÄ operator replaces name  objects  that 
Äresolve to operators in the context of the current dictionary stack by the 
Äoperator  objects  themselves.  ÑbindÄ  applies itself to the  body  of  the 
Äoperand procedure,  and recursively to the bodies of all procedure objects 
Änested therein.  This has two consequences:  (1) re-definition of  current 
Äoperator  names will not affect the behavior of the bound  procedure,  and 
Ä(2) execution will be speeded as bound operators are referred to  directly 
Ärather than through an association.Ç| 1 ls

Çtogglefonts
ÇcÄVMÖ OPERATORSÇ| 1 ls

ÇnÄ                     --Ç| tÄ Ç| tÅvmstatusÇ| tÄmax usedÇ|
ÇnÄ                     --Ç| tÄ Ç| tÅsaveÇ| tÄboxÇ|
ÇnÄ                    boxÇ| tÄ Ç| tÅcapsaveÇ| tÄ--Ç|
ÇnÄ                    boxÇ| tÄ Ç| tÅrestoreÇ| tÄ(restored objects)Ç|
ÇnÄ               0/parentÇ| tÄ Ç| tÅnextobjectÇ| tÄobjÇ|
Çtogglefonts

ÇpÄThe  values of internal objects that are created during a D  session  are 
Äaccumulated  in  the  virtual memory,  eventually  filling  all  available 
Äphysical space. ÑvmstatusÄ lets you examine the current capacity and usage of VM Äspace. ÑsaveÄ, ÑcapsaveÄ, andÑ restoreÄ let you mark and reclaim used VM space.Ç|

ÇpÑsaveÄ creates a box object in internal VM, in which it deposits a copy of the Äcurrent operand and dictionary stacks and the current level of used VM space. ÄWhen following some intermediate activities ÑrestoreÄ is applied to this box Äobject, it restores the operand and dictionary stacks to those existing by the Ätime when the box was created by ÑsaveÄ and it also discards all VM objects Äcreated after that instance of ÑsaveÄ. This could leave object descriptions in theÄ machine (on the execution stack or composite objects remaining in the VM) that Ärefer to discarded VM objects. Therefore, ÑrestoreÄ scans the execution stack for Äsuch references before it makes changes to stacks or the VM (it terminates with Äan error if it finds a reference). ÑrestoreÄ then discards the VM objectsÑ Äand Äscans all remaining VM objects for references to discarded objects. It replaces Ädiscarded objects in lists by ÑnullÄ or purges associations with discarded objectsÄ from dictionaries.Ç|

ÇpÄIf ÑcapsaveÄ is applied to a ÑsaveÄ box object, the range of discardable VM objectsÄ is limited to those created between ÑsaveÄ and ÑcapsaveÄ. When ÑrestoreÄ is applied Äto a capped save box, it deletes the enclosed range of VM objects and in Äaddition moves all objects created after those in the discardable range to Äcompact the used VM space (references to moved objects will be automatically Äcorrected in remaining objects).Ç|

ÇpÄNote thatÑ restore Äapplied to a capped save boxalso re-establishes the state of Äthe operand and dictionary stacks that existed by the time of ÑsaveÄ. Therefore, Äyou cannot return on these stacks results from the activity that was concluded Äby Ñrestore. ÄSince Ñrestore Ädoes not affect information stored in remaining VM Äobjects (except for references to deleted objects), changes to these values madeÄ during the terminated activity will persist and can be used in subsequent Äactivities.Ç|Ä 

ÇpÑnextobjectÄ retrieves a composite object from VM. If used with a zero numeral 
Äoperand, the first object created in the VM is retrieved; with a VM object givenÄ as operand, the next object created after the operand object is retrieved. 
ÄApplying ÑnextobjectÄ repeatedly to each retrieved object will scan the VM objectsÄ in their order of creation. Note that only parent objects are accessible to ÑnextobjectÄ, since no record of children objects is maintained in VM. In this Äway, you can locate a 'lost' object, for which you have not saved a reference. ÑnextobjectÄ also can serve to verify VM integrity.Ç|Ä Ç1 ls

Çtogglefonts
ÇcÄEÖXTERNAL VM OPERATORSÇ| 1 ls

ÇnÄ Ç  Ä                 cid lunÇ| tÄ Ç| tÅinitiateÇ| tÄroot_obj eVMidÇ|
ÇnÄ                      eVMidÇ| tÄ Ç| tÅreleaseÇ| tÄ--Ç|
ÇnÄ                      eVMidÇ| tÄ Ç| tÅevmstatusÇ| tÄcid lun total free trueÇ|
ÇnÄ                           Ç| tÄ Ç| tÄ         Ç| tÄ or falseÇ|
ÇnÄ                         --Ç| tÄ Ç| tÅupdateÇ| tÄ--Ç|
ÇnÄ                 longarray†1Ç| tÄ Ç| tÅevmsÇ| tÄlongarray†2Ç|
ÇnÄ               eVMid n typeÇ| tÄ Ç| tÅearrayÇ| tÄarrayÇ|
ÇnÄ                    eVMid nÇ|Ä ÇtÄ Ç| tÅelistÇ| tÄlistÇ|
ÇnÄ                    eVMid nÇ| tÄ Ç| tÅedictÇ| tÄdictÇ|
ÇnÄ                 root eVMidÇ| tÄ Ç| tÅtoboxÇ| tÄboxÇ|
ÇnÄ                        boxÇ| tÄ Ç| tÅfromboxÇ| tÄrootÇ|
ÇnÄ              array index nÇ|Ä ÇtÄ Ç| tÅgetintervalÇ| tÄsubarrayÇ|
ÇnÄ               list index nÇ| tÄ Ç| tÅ           Ç| tÄsublistÇ|
ÇnÄ               array n typeÇ| tÄ Ç| tÅparcelÇ| tÄsubarray†2Ä subarray†1Ç|
ÇnÄ       array†1Ä index†1Ä array†2Ç| tÄ Ç| tÅfaxÇ| tÄarray†1Ä index†2Ç|
ÇnÄ         list†1Ä index†1Ä list†2Ç| tÄ Ç| tÄ   Ç| tÄlist†1Ä index†2Ç|
ÇnÄ                dict†1Ä dict†2Ç| tÄ Ç| tÅmergeÇ| tÄdict†1Ç|
ÇnÄ                    eVM_objÇ| tÄ Ç| tÅvalidÇ| tÄstamp (or error)Ç|
ÇnÄ              eVMid/eVM_objÇ| tÄ Ç| tÅnextobjectÇ| tÄobjÇ|
ÇnÄ              eVMid/eVM_objÇ| tÄ Ç| tÅetrashÇ| tÄ--Ç|
ÇnÄkey eVMid array eVMadr boolÇ| tÄ Ç| tÅevmdirectÇ| tÄ--Ç|
Çtogglefonts

ÇpÄA mass storage medium that serves as an external VM is mounted for use  by 
ÑinitiateÄ  and  removed  by ÑreleaseÄ.  Every medium carries  a  unique  (word 
Äinteger)  identifier,  which  serves to specify the medium  to  operators. 
ÑinitiateÄ  reads  and returns this identifier and the root object  of  the 
Ämedium. The root object is created by the time the medium is formatted and 
Äis a dictionary. ÑevmstatusÄ inquires the status of an eVM; it returns ÑfalseÄ 
Äif  no eVM with the given identifier is in use.  Information is  exchanged 
Äbetween  internal and external storage through a cache;  ÑupdateÄ writes  to 
Äthe media all modified information currently held in cache.  ÑevmsÄ inquires 
Äwhich  eVM's  are currently in use;  their identifiers are returned  in  a 
Äsubarray of the operand.Ç|

ÇpÄThree  operators  (ÑedictÄ,  ÑelistÄ,  and ÑearrayÄ) Ñde novoÄ  create  composite 
Äobjects in eVM. They return the logical object just created, which carries 
Äthe  identifier  of  the eVM where the value of the  composite  object  is 
Äphysically located.Ç|

ÇpÄCollections  of objects that are organized as a tree (comprising  a  root 
Älist  or  dictionary and all internal objects referred to therein  to  any 
Älevel of nesting) can be saved and retrieved as an entity. ÑtoboxÄ creates a 
Äcompacted  copy of the object tree and transfers the copy into a  new  box 
Äobject  in  eVM;  ÑfromboxÄ  copies  the contents of such  a  box  into  VM, 
Äreturning the root object of the recovered tree in VM.Ç|

ÇpÄComposite object values are moved to and/or from external arrays,  lists, 
Äand  dictionaries  by expert operators.  ÑfaxÄ transfers  values  among  any 
Äcombination  of  Ñexternal Ä  or ÑinternalÄ arrays  (or  lists).  ÑmergeÄ  works 
Äsimilarly  with  dictionaries;   it  includes  all  associations  of   one 
Ädictionary  into  another  (re-defining pre-existing  names  like  ÑdefÄ  or 
ÑnameÄ).Ç|

ÇpÄOther operators that work with external as well as with internal  objects 
Äinclude ÑlengthÄ, ÑusedÄ,Ñ readonlyÄ, ÑmkreadÄ, ÑparentÄ, ÑexternalÄ, ÑgetintervalÄ, and ÑparcelÄ.
ÄIndices  and  sizes of external byte subarrays created by  ÑgetintervalÄ  or 
Ñparcel  Äare  restricted  to  even values only  (odd  values  could  create 
Äphysical alignment problems too cumbersome to circumvent).Ç|

ÇpÄSometimes you may lose access to an object in external VM (by forgetting 
Äto  save  appropriate references).  ÑnextobjectÄ lets you scan  the  objects 
Äaccumulated in an eVM one at a time.  When ÑnextobjectÄ is given a  positive 
Äor negative eVM identifier,  it retrieves the first temporary or permanent 
ÄeVM  object;  when  given  an eVM  object,  it  retrieves  the  subsequent 
Ä(temporary or permanent) eVM object.  ÑnextobjectÄ proceeds in the order  of 
Äcreation  for  permanent objects,  or in the reverse order  for  temporary 
Äobjects.Ç|

ÇpÄYou can check the validity of an external object by ÑvalidÄ.  If the  given 
Äobject  has no valid value in eVM,  an error is generated.  If  the  value 
Äexists,  the time stamp of its creation is returned;  this time stamp is a 
Älong  numeral that holds a bitwise compaction of time and date (see  ÑvalidÄ 
Äoperator in the Operator Lexicon).Ç|

ÇpÄTemporary  eVM objects are deleted by ÑdiscardÄ.  The operator removes  from 
Äthe  temporary  eVM  space the specified object value  and  all  temporary 
Äobject  values created thereafter.  Permanent eVM objects can  be  removed 
Äonly by repriming the entire medium.Ç|

ÇpÄA non-public operator, ÑevmdirectÄ, provides access to the physical medium, 
Äbypassing the eVM organization (this operator uses the byte-array  logical 
Äaddress  space  provided through the eVM cache facility).  Access  at  the 
Äphysical device level is provided by SCSI port operators described below.Ç| 1 ls


Çtogglefonts
ÇcÄVÖIRTUAL TERMINAL OPERATORSÇ| 1 ls

ÇnÄ       scr# #rows dialog wpÇ| tÄ Ç| tÅmaketextscreenÇ| tÄ--Ç|
ÇnÄ                    screen#Ç| tÄ Ç| tÅtextscreenÇ| tÄrows dialog wp true / falseÇ|
ÇnÄ     scr# left top w h dictÇ| tÄ Ç| tÅmakegraphscreenÇ| tÄ--Ç|
ÇnÄ                    screen#Ç| tÄ Ç| tÅremovescreenÇ| tÄ--Ç|
ÇnÄ                    screen#Ç| tÄ Ç| tÅshowscreenÇ| tÄ--Ç|
ÇnÄ                         --Ç| tÄ Ç| tÅcurrentscreenÇ| tÄscreen#Ç|
ÇnÄ                     stringÇ| tÄ Ç| tÅfromconsoleÇ| tÄsubstring true / falseÇ|
ÇnÄ                     stringÇ| tÄ Ç| tÅtoconsoleÇ| tÄ--Ç|
ÇnÄ                     stringÇ| tÄ Ç| tÅtoqueueÇ| tÄ--Ç|
ÇnÄ                         --Ç| tÄ Ç| tÅthinkÇ| tÄ--Ç|
ÇnÄ             screen# stringÇ| tÄ Ç| tÅfromtextscreenÇ| tÄsubstringÇ|
ÇnÄ             string screen#Ç| tÄ Ç| tÅtotextscreenÇ| tÄ--Ç|
ÇnÄ               screen# procÇ| tÄ Ç| tÅusescreenÇ| tÄ--Ç|
ÇnÄ             samples paramsÇ| tÄ Ç| tÅdrawsamplesÇ| tÄ--Ç|
ÇnÄ                  xy paramsÇ| tÄ Ç| tÅdrawlineÇ| tÄ--Ç|
ÇnÄ                  xy paramsÇ|Ä ÇtÄ Ç| tÅdrawsymbolsÇ| tÄ--Ç|
ÇnÄ          x y string paramsÇ| tÄ Ç| tÅdrawtextÇ| tÄx yÇ|
ÇnÄ                  xy paramsÇ|Ä ÇtÄ Ç| tÅfillrectangleÇ| tÄ--Ç|Ä 
Çtogglefonts

ÇpÄThe principles of the VT are described in section 2.5. This section gives you Äan overview of the VT operators.Ç|

ÇpÄIn addition to the console screen, which is created automatically when D is Ästarted up, text or graph screens can be created by Ñmaketextscreen ÄandÑ ÑmakegraphscreenÄ. These screens are randomly numbered from 1-9 (0 is used for theÄ console screen). A text screen has fixed dimensions (which hence need not be 
Äspecified), but has a variable text memory size (specified in rows of 80 columnsÄ capacity) and variable behavior (specified by the booleans, ÑdialogÄ (true: Ädialogue screen, false: edit screen) and ÑwpÄ (true: word processing, false: plainÄ ASCII). These settings can be inquired by Ñtextscreen.Ä A graph screen has Ävariable dimensions and a variable location (specified in pixel units relative Äto the top, left corner of the physical screen, and counting down and right as Äpositive displacements). If zero dimensions are specified, the graph screen is aÄ menu screen (with fixed size and location). ÑremovescreenÄ removes either kind ofÄ screen (except the console screen, which is permanent).Ç|

ÇpÄA superimposed screen is brought forward by ÑshowscreenÄ, and the number of the Ätext screen currently in the foreground is inquired by Ñcurrentscreen.Ä Screens Äcan be moved to the foreground also by pressing numeral keys of the numeric Äkeypad together with 'control'. Keystrokes are directed to the current text Äscreen (i.e. the text screen last selected).Ç|

ÇpÄA program can receive a phrase entered to the console screen by ÑfromconsoleÄ. ÑfromconsoleÄ waits until a complete phrase (concluded by 'enter') has been typed Ä(the screen shows phrases not yet consumed in blue; such text is still subject Äto editing). It returns one phrase at a time.Ñ ÄWhile ÑfromconsoleÄ is waiting for aÄ console phrase, the D mill remains capable of responding to other demands (likeÄ drawing of a graph screen or responding to a mouse click).Ç|

ÇpÑtoconsole Äand ÑtoqueueÄ write text to the console. Text displayed on the console Äscreen is divided into a dialogue zone (black letters) and an edit zone (blue Äletters). Keystrokes and Ñtoqueue Äenter text at the end of the edit zone, whereasÄ ÑtoconsoleÄ inserts text at the end of the dialogue zone. The contents of the Äedit zone are submitted, one phrase at a time, to the D mill for interpretation Äor are received by Ñfromconsole. ÄEach processed phrase is transferred into the Ädialogue zone (thus changing color from blue to black). Note that ÑtoqueueÄ can Äqueue synthesized phrases for execution by the D mill.Ç|

ÇpÑthinkÄ sounds the alert signal currently in use.Ç|

ÇpÄText is exchanged between the memory of text screens and a string by ÑtotextscreenÄ and ÑfromtextscreenÄ. Text submitted by ÑtotextscreenÄ may or may not 
Äcontain escape sequences that specify word-processing enhancements; if enhanced Ätext is sent to a plain ASCII screen, the escape sequences are stripped from theÄ text; ASCII text is inserted as is into a word-processing screen. The console Äscreen is a plain ASCII screen. String buffers need to be dimensioned to hold 81Ä characters per screen row in ASCII format, plus extra space for escape Äsequences in WP format (each change of enhancement options yields 2 Ächaracters).Ç|

ÇpÄGraph screens communicate with the D mill when they need to have their contentsÄ drawn or when a mouse click needs attention. To this end, Ñmakegraphscreen Ärequires a dictionary operand, ÑdictÄ. This dictionary is expected to associate  Äthe names 'drawscreen' and 'mouseclick' with suitable procedures. When the graphÄ screen requires attention (in response to events originating by user actions orÄ operating system actions), the D mill pushes ÑdictÄ on the dictionary stack and Äexecutes one of the active names 'drawscreen' or 'mouseclick', thus interruptingÄ the execution of the current D context to execute a screen service procedure. ÄThis procedure is expected to remove ÑdictÄ from the dictionary stack when it Äcloses up.Ç|

ÇpÑusescreenÄ stores the current screen selection, selects a new Ñscreen#Ä, executes ÑprocÄ, and finally restores the previous screen selection. This encapsulation is Änecessary. The mill can interrupt an ongoing context (even during screen Äactivity) and schedule 'drawscreen'; ÑusescreenÄ safeguards interrupted activitiesÄ against random switches among screens. When ÑusescreenÄ invokes ÑprocÄ, it presents
Ä the width and height (in pixels) of the selected screen on top of the operand Ästack.Ç|

ÇpÄThe other graphical operators provide a set of graphical primitives of which 
Äcomplex screens can be constructed. These operators receive coordinate Äinformation specified by Ñxy Äin a variety of forms. Coordinates are presented Äeither as separate abscissa and ordinate arrays or lists, or are presented in Äone list or array that holds alternating abscissa and ordinate values. ÑparamsÄ isÄ an array or list that provides operator-specific additional information, such Äas symbol or line pattern, color, etc.Ç|

ÇpÑdrawsamples Äis designed to present large sets of samples in a very quick Äfashion. The word array ÑsamplesÄ contains the data ordinates; the abscissa is Äautomatically constructed by ÑdrawsamplesÄ. Ñparams Äcontains scaling information, Äcolor selection, and a drawing mode (you can erase a curve or draw it). Samples Äare scaled while being projected on the screen. The drawing rate of ÑdrawsamplesÄ Äis sufficient to present a million samples in less than a second. It thus is Äuseful in inspecting a large set of raw data.Ç|

ÇpÑdrawline Älets you interconnect sets of coordinates with solid lines of variableÄ color. ÑdrawsymbolsÄ draws a centered symbol for each coordinate pair; you can 
Äselect color, size, and among 21 symbols including a set of scale ticks. ÑdrawtextÄ draws a text at a specified location and returns the new coordinates Ä(useful for placing more text in a varied style or for measuring the actual Äwidth of a text). Texts are rendered in variable font, style (like bold), size, Äcolor, and alignment (like centered). ÑfillrectangleÄ uses a variable color and/orÄ pattern.Ç| 1 ls

Çtogglefonts
ÇcÄFÖILE MANAGEMENT OPERATORSÇ| 1 ls

ÇnÄ               dirspecÇ| tÄ Ç| tÅfinddirÇ| tÄvolid diridÇ|
ÇnÄ        vol dir stringÇ| tÄ Ç| tÅgetpathÇ| tÄsubstringÇ|
ÇnÄ                  listÇ| tÄ Ç| tÅgetvolumesÇ| tÄsublistÇ|
ÇnÄ        vol/(volname:)Ç| tÄ Ç| tÅdiskspaceÇ| tÄtotal freeÇ|
ÇnÄvol dir (template) list strÇ| tÄ Ç| tÅfindfilesÇ| tÄfilelist boolÇ|
ÇnÄ       filespec stringÇ| tÄ Ç| tÅreadfileÇ| tÄdata resourceÇ|
ÇnÄdata resource filespecÇ| tÄ Ç| tÅwritefileÇ| tÄ--Ç|
ÇnÄ              filespecÇ| tÄ Ç| tÅdeletefileÇ| tÄ--Ç|
ÇnÄ   vol dir (old) (new)Ç| tÄ Ç| tÅrenamefileÇ| tÄ--Ç|
ÇnÄ     vol par (dirname)Ç| tÄ Ç| tÅmakedirÇ| tÄvolid diridÇ|
ÇnÄ     vol dir (dirname)Ç| tÄ Ç| tÅdeletedirÇ| tÄ--Ç|
ÇnÄ        vol/(volname:)Ç| tÄ Ç| tÅunmountvolumeÇ| tÄ--Ç|
Çtogglefonts

ÇpÄA set of operators lets you access and manage the file systems of the host 
Äcomputer. The organization of these operators is to some extent host-specific. ÄApple computers organize their files in volumes and directory trees.Ç|

ÇpÄ A volume is specified either by (name:) or by an integer identification numberÄ (volID), which is assigned to the medium at the time of mounting (-1 for the Äboot medium, -2 and so forth for media mounted thereafterÑ.Ä Whereas volume names Äare not unique, the volID is; on the other hand, volume names are permanent Ä(unless changed explicitely), whereas volIDs live only for one session. Volumes Äusually are mounted simply by physical manipulation (like inserting a floppy), Äbut have to be unmounted explicitly by ÑunmountvolumeÄ (this triggers the physicalÄ release). ÑgetvolumesÄ inquires the list of currently mounted volumes, and ÑdiskspaceÄ inquires the total and unused byte capacities of a volume.Ç|

ÇpÄEach directory in a volume carries a permanent and unique directory Äidentification number (dirID). These are positive integers, starting from 2 Ä(root directory). Directories also have names. Again, the dirID is the Äpreferable reference, because directory names are often long and cumbersome to Ätype, are generally not unique, and can be changed. The path of a particular Ädirectory can be inquired by ÑgetpathÄ, but a specification in terms of volID and ÄdirID is the method of specification for access. This specification can be Äassembled from a known volID, parent dirID, and a directory name using ÑfinddirÄ. 
ÄThe following are examples of valid operand combinations for ÑfinddirÄ and other Äfile operators:Ç| 1 ls

Ç/oldtabs tabs defÄ 
Ç/tabs [ [ 72 1 ] [textwidth 1] ] def 
Çtogglefonts
ÇnÄ Ç| tÅ0 0 (volname)Ä              Ç      |
ÇnÄ Ç| tÅvolID 2 (:dirname)Ä               Ç|
ÇnÄ Ç| tÅvolID parentID (:dirname)Ä        Ç|
ÇnÄ Ç| tÅvolID dirID (:dirname:dirname)Ä   Ç|
Çtogglefonts
Ç/tabs oldtabs def

ÇpÄIndividual files have file names (which like volume and directory names cannot Äinclude ':' characters). File name extensions can be formed, but have no Äsyntactical relevance (in fact '.' is a character like any other in a file Äname). Files whose names match a template can be inquired from the directory by Ñfindfiles.Ä The name template may contain any number of '*' wildcard characters Ä(each of which stands for an unspecified number of arbitrary characters not 
Äconsidered in the comparison). ÑfindfilesÄ returns a file list that holds names, Äsize, attribute, and date/time information for each matching file. Files are Äspecified by volID, dirID, and a string like directories (see examples above).Ç|

ÇpÄApple files contain two subsets of information, usually referred to as the dataÄ and resource forks. In addition, the internal file specification contains an Ä8-byte string that classifies the nature of the file contents and the program Äthat created it (this specification takes on the role that the file name Äextension has in other systems). ÑreadfileÄ returns, and ÑwritefileÄ accepts, the 
Ätwo forks in separate byte arrays, with the 8-byte specifier prefixed to the Äcontents of the resource fork (if there is no resource fork, the resource byte Äarray holds only the 8-byte specifier). Note that it is vital for the usefulnessÄ of a file that both parts including the specifier be transferred when the file Äis copied using D file operators. If you create a file de novo, you have to Ächoose a specifier; 'TEXTDDDD' is suitable for text files created by D Äfacilities (like editing); such text files generally will be accepted by other ÄApple applications.Ç|

ÇpÄDirectories or files can be deleted by Ñdeletedir Äor ÑdeletefileÄ; before a Ädirectory is deleted, it has to be emptied by deleting its contents. Both Ädirectories and files can be renamed by ÑrenamefileÄ.Ç| 1 ls


Çtogglefonts
ÇcÄPÖORT OPERATORSÇ| 1 ls

ÇnÄ              cid cdb limÇ| tÄ Ç| tÅscsi_kickÇ| tÄstatusÇ|
ÇnÄ         cid cdb lim dataÇ|Ä ÇtÄ Ç| tÅscsi_writeÇ| tÄstatusÇ|
ÇnÄ        Ç Äcid cdb lim dataÇ| tÄ Ç| tÅscsi_readÇ| tÄstatusÇ|
ÇnÄ Ö Ä[params] /in /out /portÇ|Ä ÇtÄ Ç| tÅportsessionÇ| tÄboolÇ|
ÇnÄ                       --Ç| tÄ Ç| tÅcloseportÇ| tÄ--Ç|
ÇnÄ         string stringbufÇ| tÄ Ç|Ä ÇtÅencode_85Ç| tÄ85_stringÇ|
ÇnÄ      85_string stringbufÇ| tÄ Ç| tÅdecode_85Ç| tÄstring boolÇ|
Çtogglefonts

ÇpÄPeripherals  attached  to  the host through an SCSI  port  are  addressed 
Ädirectly through SCSI port operators. These support actions that do not involve 
Äa  'data  phase'  (Ñscsi_kickÄ),  or do transfer data  in  either  direction 
Ä(Ñscsi_readÄ,  Ñscsi_writeÄ).  Transactions  are safeguarded  against  hang-up 
Äconditions through a time-out interval (positive: msec, negative microsec) or  Ämay be allowed to wait indefinitely (cave hangups!). The  operand 
Äabbreviations stand for 'controller identification number' (cid), 'command 
Ädescriptor block' (cdb), and 'timeout limit' (lim).Ç|

ÇpÄExternal  mass  storage holding eVMs or host file  systems  typically  is 
Äinterfaced  through the SCSI port.  Expert operators see to safe  uses  of 
Äthese  media,  whereas SCSI port operator action is  unrestricted.  Direct 
Äaction  by port operators is used in utilities that format or  prime  mass 
Ästorage  media,  but  is not recommended otherwise.  Port  operators  also 
Äpermit  quick  interfacing of custom SCSI devices through  on-board  means. IfÄ you use SCSI port operators, however, make sure you know what you are doing!Ç|

ÇpÄCommunication with other computers or peripherals that involves a two-way Ästream of information is establishedÑ Äby Ñportsession Äand terminated by Ñcloseport.Ä Currently supported are the serial ports A and B, and a PAP port for accessing Älaserprinters over a network.  These operators create a special behavior of the ÄD machine called a 'session'. During a session, the D machine attends to random Ädemands made by the communication port, but remains capable of executing Äunrelated D code (like mouse response routines) and of sharing time with other ÄApple applications. ÑportsessionÄ maintains a transparent polling loop that Ärecognizes port demands; ÑcloseportÄ terminates this loop (ÑstopÄ and Ñabort Äalso canÄ terminate a port session). The D machine cannot maintain concurrent sessions onÄ several ports.Ç|

ÇpÑportsessionÄ operands include a parameter list, which specifies operating modes Äof the port (like baudrate) and designates a buffer for received data. Three Äname operands designate procedures for processing data received on the port (ÑinÄ)Ä and for providing data to be transmitted on the port (ÑoutÄ), and select the portÄ (ÑportÄ). (ÑinÄ, ÑoutÄ, and ÑportÄ stand for arbitrary names that you may choose). The Äactive name Ñout Äis pushed on the execution stack when the port is 
Äready to transmit a package of data; associate Ñout Äwith a procedure that pushes Äa string holding data on the operand stack, or a ÑnullÄ object if no transmission Äis intended at this time (Ñout Äwill be executed repeatedly while the port is Äready; thus it effectively polls your program for a transmission request). The Äactive name ÑinÄ is pushed on the execution stack when the port has received a Äpackage of data (whose size is defined by the port protocol); Ö Äassociate ÑinÄ withÄ a procedure that receives the data string on the operand stack and consumes theÄ string contents before it closes up. Either procedure can execute ÑcloseportÄ; Äexecution then will continue with the object following ÑportsessionÄ. A boolean Äindicating termination by Ñcloseport Ä(false) or ÑstopÄ (true) is pushed on the Äoperand stack. Note that ÑportsessionÄ refers to the names provided under ÑinÄ and ÑoutÄ; you can dynamically associate varying procedures to these names in order toÄ build a communication protocol that involves an ordered sequence of several Ätransactions.Ç|

ÇpÄThe required ÑparametersÄ are port-specific. For details, look up Ñportsession Äin Äthe Operator Lexicon.Ç|

ÇpÄData exchanged across serial ports typically cannot include binary patterns Äthat code for control characters of the ASCII table. Binary information, Ätherefore, will need to be re-coded to be expressed in patterns that do not Äinclude control characters. ASCII85 is one such coding method and is commonly Äused. Two operators, Ñencode_85 Äand Ñdecode_85Ä perform this transform in the Äforward and reverse directions. Since generally 4 binary bytes are re-coded intoÄ 5 ASCII85 bytes, the ASCII85-encoded string requires about 25% more storage Äspace than the original string of binaries.Ç| 1 ls

Çtogglefonts
ÇcÄMÖISCELLANEOUS OPERATORSÇ| 1 ls

Çn       Ä                --Ç| tÄ Ç| tÅgettimeÇ| tÄsec min hourÇ|
ÇnÄ                       --Ç| tÄ Ç| tÅgetdateÇ| tÄyear day monthÇ|
Çtogglefonts

ÇpÄThese operators tap the host's time-keeping facilities. Note also that the D Ämill schedules for execution the active name 'interrupt' after each 100 ms Äinterval. 'interval' can be associated with a procedure that performs timed Äfunctions (the default association is with a dummy, 'no-op' operator).Ç|
Å                

