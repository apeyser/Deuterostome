#line 2 "./dm-petsc.c.in"
#include <petscksp.h>

#include <limits.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include "dm.h"

#define D_ARRAY_PTR(frame) (*(D**) &VALUE_PTR(frame))
#define VECTOR_VAL(frame) (*(Vec*) VALUE_PTR(frame))
#define MATRIX_VAL(frame) (*(Mat*) VALUE_PTR(frame))
#define L32_VAL(frame) (*(L32*) NUM_VAL(frame))
#define L32_ARRAY_PTR(frame) (*(L32**) &VALUE_PTR(frame))
#define KSP_VAL(frame) (*(KSP*) VALUE_PTR(frame))

#include "dm-dmpetsc-header.h"

static PetscErrorCode petscsig(int sig __attribute__ ((__unused__)), 
			       void* ptr __attribute__ ((__unused__)) ) {
  return PETSC_ERR_SIG;
}

static P errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_INDEFINITE_MAT) + 1];

DM_INLINE_STATIC P init_(void) {
  PetscErrorCode r;

  if (setenv("PETSC_DIR", "@PETSC_DIR@", 1))
    return -errno;
  if (setenv("PETSC_ARCH", "@PETSC_ARCH@", 1))
    return -errno;

  errmap[0] = OK;
  errmap[PETSC_ERR_MEM] = DMPETSC_ERR_MEM;
  errmap[PETSC_ERR_SUP] = DMPETSC_ERR_SUP;
  errmap[PETSC_ERR_SUP_SYS] = DMPETSC_ERR_SUP_SYS;
  errmap[PETSC_ERR_ORDER] = DMPETSC_ERR_ORDER;
  errmap[PETSC_ERR_SIG] = DMPETSC_ERR_SIG;
  errmap[PETSC_ERR_FP] = DMPETSC_ERR_FP;
  errmap[PETSC_ERR_COR] = DMPETSC_ERR_COR;
  errmap[PETSC_ERR_LIB] = DMPETSC_ERR_LIB;
  errmap[PETSC_ERR_PLIB] = DMPETSC_ERR_PLIB;
  errmap[PETSC_ERR_MEMC] = DMPETSC_ERR_MEMC;
  errmap[PETSC_ERR_CONV_FAILED] = DMPETSC_ERR_CONV_FAILED;
  errmap[PETSC_ERR_USER] = DMPETSC_ERR_USER;
  errmap[PETSC_ERR_ARG_SIZ] = DMPETSC_ERR_ARG_SIZ;
  errmap[PETSC_ERR_ARG_IDN] = DMPETSC_ERR_ARG_IDN;
  errmap[PETSC_ERR_ARG_WRONG] = DMPETSC_ERR_ARG_WRONG;
  errmap[PETSC_ERR_ARG_CORRUPT] = DMPETSC_ERR_ARG_CORRUPT;
  errmap[PETSC_ERR_ARG_OUTOFRANGE] = DMPETSC_ERR_ARG_OUTOFRANGE;
  errmap[PETSC_ERR_ARG_BADPTR] = DMPETSC_ERR_ARG_BADPTR;
  errmap[PETSC_ERR_ARG_NOTSAMETYPE] = DMPETSC_ERR_ARG_NOTSAMETYPE;
  errmap[PETSC_ERR_ARG_NOTSAMECOMM] = DMPETSC_ERR_ARG_NOTSAMECOMM;
  errmap[PETSC_ERR_ARG_WRONGSTATE] = DMPETSC_ERR_ARG_WRONGSTATE;
  errmap[PETSC_ERR_ARG_INCOMP] = DMPETSC_ERR_ARG_INCOMP;
  errmap[PETSC_ERR_ARG_NULL] = DMPETSC_ERR_ARG_NULL;
  errmap[PETSC_ERR_ARG_UNKNOWN_TYPE] = DMPETSC_ERR_ARG_UNKNOWN_TYPE;
  errmap[PETSC_ERR_ARG_DOMAIN] = DMPETSC_ERR_ARG_DOMAIN;
  errmap[PETSC_ERR_FILE_OPEN] = DMPETSC_ERR_FILE_OPEN;
  errmap[PETSC_ERR_FILE_READ] = DMPETSC_ERR_FILE_READ;
  errmap[PETSC_ERR_FILE_WRITE] = DMPETSC_ERR_FILE_WRITE;
  errmap[PETSC_ERR_FILE_UNEXPECTED] = DMPETSC_ERR_FILE_UNEXPECTED;
  errmap[PETSC_ERR_MAT_LU_ZRPVT] = DMPETSC_ERR_MAT_LU_ZRPVT;
  errmap[PETSC_ERR_MAT_CH_ZRPVT] = DMPETSC_ERR_MAT_CH_ZRPVT;

  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_NULL)] 
    = DMPETSC_DIVERGED_NULL;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_ITS)] 
    = DMPETSC_DIVERGED_ITS;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_DTOL)] 
    = DMPETSC_DIVERGED_DTOL;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_BREAKDOWN)] 
    = DMPETSC_DIVERGED_BREAKDOWN;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_BREAKDOWN_BICG)] 
    = DMPETSC_DIVERGED_BREAKDOWN_BICG;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_NONSYMMETRIC)] 
    = DMPETSC_DIVERGED_NONSYMMETRIC;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_INDEFINITE_PC)] 
    = DMPETSC_DIVERGED_INDEFINITE_PC;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_NAN)] 
    = DMPETSC_DIVERGED_NAN;
  errmap[PETSC_ERR_MAX_VALUE + (-KSP_DIVERGED_INDEFINITE_MAT)] 
    = DMPETSC_DIVERGED_INDEFINITE_MAT;

  if ((r = PetscInitialize(PETSC_NULL, PETSC_NULL, PETSC_NULL, PETSC_NULL)))
    RETURN_ERROR(errmap[r]);

  if ((r = PetscPushSignalHandler(petscsig, NULL)))
    RETURN_ERROR(errmap[r]);

  return OK;
}

DM_INLINE_STATIC P fini_(void) {
  PetscErrorCode r;
  if ((r = PetscPopSignalHandler()))
    RETURN_ERROR(errmap[r]);
  
  return OK;
}


DM_INLINE_STATIC P INIT_VEC_(B* frame, Vec* x) {
  TEST_DMPETSC_VECTOR(frame);
  if (! (*x = DMPETSC_VECTOR_VECTOR(frame))) 
    RETURN_ERROR(DMPETSC_INVVEC);
  return OK;
}

#define INIT_VEC(frame, x) do {						\
    P retc = INIT_VEC_(frame, &x);					\
    if (retc) return retc;						\
  } while (0)

DM_INLINE_STATIC P INIT_MAT_(B* frame, Mat* A) {
  TEST_DMPETSC_MATRIX(frame);
  if (! (*A = DMPETSC_MATRIX_MATRIX(frame))) 
    RETURN_ERROR(DMPETSC_INVMAT);
  return OK;
}

#define INIT_MAT(frame, A) do {						\
    P retc = INIT_MAT_(frame, &A);					\
    if (retc) return retc;						\
  } while (0)

DM_INLINE_STATIC P INIT_KSP_(B* frame, KSP* ksp) {
  TEST_DMPETSC_KSP(frame);
  if (! (*ksp = DMPETSC_KSP_KSP(frame)))
    RETURN_ERROR(DMPETSC_INVKSP);
  return OK;
}

#define INIT_KSP(frame, ksp) do {		\
    P retc = INIT_KSP_(frame, &ksp);		\
    if (retc) return retc;			\
  } while (0)

#define DMPETSC_ERRCHECK(func) do {					\
    PetscErrorCode r;							\
    if ((r = func)) RETURN_ERROR(errmap[r]);				\
  } while (0)


//------------------------ petsc_vector_create
// n | vec-handle
// n is the size of the local portion of the vector.
// the total size is n1+n2... over all mpi processes
//
DM_INLINE_STATIC P petsc_vec_create(void) {
  PetscErrorCode r;
  P n;
  B* pframe;
  B* oldfreevm = FREEvm;
  Vec* x = NULL;

  if (o_1 < FLOORopds) return OPDS_UNF;
  if (CLASS(o_1) != NUM) return OPD_CLA;
  if (! PVALUE(o_1, &n)) return UNDF_VAL;

  MAKE_DMPETSC_VECTOR(pframe, 0);
  x = &DMPETSC_VECTOR_VECTOR(pframe);
  *x = NULL;  
  DMPETSC_VECTOR_N(pframe) = n;

  if ((r = VecCreateMPI(PETSC_COMM_WORLD, n, PETSC_DECIDE, x)))
    goto err;

  moveframe(pframe, o_1);
  return OK;

 err:
  if (x && *x) VecDestroy(*x);
  *x = NULL;
  FREEvm = oldfreevm;
  RETURN_ERROR(errmap[r]);
}

// v1 v2 | v2
DM_INLINE_STATIC P petsc_vec_copy(void) {
  Vec x, y;
  
  if (o_2 > FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, y);
  INIT_VEC(o_2, x);
  if (DMPETSC_VECTOR_N(o_1) != DMPETSC_VECTOR_N(o_2)) return RNG_CHK;
  
  DMPETSC_ERRCHECK(VecCopy(x, y));
  
  moveframe(o_1, o_2);
  FREEopds = o_1;
  return OK;
}

// <d > n v | v
DM_INLINE_STATIC P petsc_vec_copyto(void) {
  Vec x;
  P n, len_arr, len_x;
  D* a;
  
  if (o_3 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, x);
  if (CLASS(o_2) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n)) return UNDF_VAL;
  if (TAG(o_3) != (ARRAY|DOUBLETYPE)) return OPD_ERR;

  len_x = DMPETSC_VECTOR_N(o_1);
  len_arr = ARRAY_SIZE(o_3);
  if (n < 0 || n+len_arr > len_x) return RNG_CHK;

  DMPETSC_ERRCHECK(VecGetArray(x, &a));
  moveD((D*) VALUE_PTR(o_3), a+n, len_arr);
  DMPETSC_ERRCHECK(VecRestoreArray(x, PETSC_NULL));

  moveframe(o_1, o_3);
  FREEopds = o_2;
  return OK;
}

// v n <d > | <d sub-array>
DM_INLINE_STATIC P petsc_vec_copyfrom(void) {
  Vec x;
  P n, len_arr, len_x, ncols;
  D* a;

  if (o_3 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_3, x);
  if (CLASS(o_2) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n)) return UNDF_VAL;
  if (TAG(o_1) != (ARRAY|DOUBLETYPE)) return OPD_ERR;

  len_x = DMPETSC_VECTOR_N(o_3);
  len_arr = ARRAY_SIZE(o_1);
  if (n < 0 || n >= len_x) return RNG_CHK;
  
  ncols = (len_x - n < len_arr) ? len_x - n : len_arr;
  DMPETSC_ERRCHECK(VecGetArray(x, &a));
  moveD(a+n, (D*) VALUE_PTR(o_3), ncols);
  DMPETSC_ERRCHECK(VecRestoreArray(x, PETSC_NULL));

  moveframe(o_1, o_3);
  ARRAY_SIZE(o_3) = ncols;
  FREEopds = o_2;
  return OK;
} 

// vec-handle | max(v)
DM_INLINE_STATIC P petsc_vec_max(void) {
  Vec x;
  D v;
  PetscInt p;

  if (FLOORopds > o_1) return OPDS_UNF;
  INIT_VEC(o_1, x);
  DMPETSC_ERRCHECK(VecMax(x, &p, &v));

  TAG(o_1) = (NUM|DOUBLETYPE);
  ATTR(o_1) = 0;
  *(D*)NUM_VAL(o_1) = v;
  return OK;
}

// vec-handle | min(v)
DM_INLINE_STATIC P petsc_vec_min(void) {
  Vec x;
  D v;
  PetscInt p;

  if (FLOORopds > o_1) return OPDS_UNF;
  INIT_VEC(o_1, x);
  DMPETSC_ERRCHECK(VecMin(x, &p, &v));

  TAG(o_1) = (NUM|DOUBLETYPE);
  ATTR(o_1) = 0;
  *(D*)NUM_VAL(o_1) = v;
  return OK;
}
  
// vec-handle | --
DM_INLINE_STATIC P petsc_vec_destroy(void) {
  Vec x;

  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, x);

  DMPETSC_ERRCHECK(VecDestroy(x));
  DMPETSC_VECTOR_VECTOR(o_1) = NULL;

  KILL_OPAQUE();
  return OK;
}

// n <l irows> <l icols> | mat
DM_INLINE_STATIC P petsc_mat_create(void) {
  PetscErrorCode r;
  P m, n;
  L32* irows;
  L32* icols;
  L32 N;
  B* pframe;
  B* oldfreevm = FREEvm;
  Mat* A = NULL;

  if (FLOORopds > o_3) return OPDS_UNF;
  if (CLASS(o_3) != NUM) return OPD_CLA;
  if (! PVALUE(o_3, &n)) return UNDF_VAL;
  if (TAG(o_2) != (ARRAY|LONG32TYPE) || TAG(o_1) != (ARRAY|LONG32TYPE))
    return OPD_ERR;
  if ((m = ARRAY_SIZE(o_2)-1) < 1) return RNG_CHK;
  if ((N = ARRAY_SIZE(o_1)) > m*n) return RNG_CHK;

  MAKE_DMPETSC_MATRIX(pframe, 0);
  A = &DMPETSC_MATRIX_MATRIX(pframe);
  *A = NULL;
  DMPETSC_MATRIX_M(pframe) = m;
  DMPETSC_MATRIX_N(pframe) = n;

  irows = (L32*) VALUE_PTR(o_2);
  icols = (L32*) VALUE_PTR(o_1);

  if ((r = MatCreate(PETSC_COMM_WORLD, A))
      || (r = MatSetType(*A, MATMPIMAIJ))
      || (r = MatSetSizes(*A, m, n, PETSC_DETERMINE, PETSC_DETERMINE))
      || (r = MatGetOwnershipRange(*A, &DMPETSC_MATRIX_GM(pframe), PETSC_NULL))
      || (r = MatMPIAIJSetPreallocationCSR(*A, irows, icols, PETSC_NULL)))
    goto err;

  moveframe(pframe, o_3);
  FREEopds = o_2;
  return OK;

 err:
  if (A && *A) MatDestroy(*A);
  *A = NULL;
  FREEvm = oldfreevm;
  RETURN_ERROR(errmap[r]);
}

DM_INLINE_STATIC P petsc_mat_destroy(void) {
  Mat A;
  
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);
  
  DMPETSC_ERRCHECK(MatDestroy(A));
  DMPETSC_MATRIX_MATRIX(o_1) = NULL;
  
  KILL_OPAQUE();
  return OK;
}

// A B | B
DM_INLINE_STATIC P petsc_mat_copy(void) {
  Mat A, B;
  
  if (o_2 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_2, A);
  INIT_MAT(o_1, B);

  DMPETSC_ERRCHECK(MatCopy(A, B, SAME_NONZERO_PATTERN));

  moveframe(o_1, o_2);
  FREEopds = o_1;
  return OK;
}

// A | B(same shape as A)
DM_INLINE_STATIC P petsc_mat_dup(void) {
  PetscErrorCode r;
  P retc = 0;
  Mat A;
  B* pframe;
  Mat* Bm = NULL;
  B* oldfreevm = FREEvm;
  L32* row;
  
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);

  MAKE_DMPETSC_MATRIX(pframe, 0);
  Bm = &DMPETSC_MATRIX_MATRIX(pframe);
  *Bm = NULL;
  DMPETSC_MATRIX_M(pframe) = DMPETSC_MATRIX_M(o_1);
  DMPETSC_MATRIX_N(pframe) = DMPETSC_MATRIX_N(o_1);

  row = &DMPETSC_MATRIX_GM(pframe);
  if ((r = MatDuplicate(A, MAT_DO_NOT_COPY_VALUES, Bm))
      || (r = MatGetOwnershipRange(*Bm, row, PETSC_NULL)))
    goto err;

  if (DMPETSC_MATRIX_GM(o_1) != *row) {
    retc = DMPETSC_ILLEGAL_OWNERSHIP;
    goto err;
  }

  moveframe(pframe, o_1);
  return OK;

 err:
  if (Bm && *Bm) MatDestroy(*Bm);
  *Bm = NULL;
  FREEvm = oldfreevm;
  RETURN_ERROR(retc ? retc : errmap[r]);
}

// <d > m n A | A
DM_INLINE_STATIC P petsc_mat_copyto(void) {
  Mat A;
  P m, n, len_arr, gm;
  L32 ncols;
  D* a;
  D* row;

  if (o_4 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_1, A);
  if (CLASS(o_2) != NUM || CLASS(o_3) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n) || ! PVALUE(o_3, &m)) return UNDF_VAL;
  if (TAG(o_4) != (ARRAY|DOUBLETYPE)) return OPD_ERR;

  gm = DMPETSC_MATRIX_GM(o_1);
  DMPETSC_ERRCHECK(MatGetRow(A, gm+m, &ncols, PETSC_NULL, (const D**)&row));
  if (FREEvm + sizeof(D)*ncols < CEILvm) moveD(row, (D*) FREEvm, ncols);
  DMPETSC_ERRCHECK(MatRestoreRow(A, gm+m, &ncols, PETSC_NULL, (const D**)&row));
  if (FREEvm + sizeof(L32)*ncols >= CEILvm) return VM_OVF;

  row = (D*) FREEvm;  
  len_arr = ARRAY_SIZE(o_4);
  if (n < 0 || n + len_arr > ncols) return RNG_CHK;
  a = (D*) VALUE_PTR(o_4);
  moveD(a, row+n, len_arr);

  DMPETSC_ERRCHECK(MatSetValuesRow(A, gm+m, row));

  moveframe(o_1, o_4);
  FREEopds = o_3;
  return OK;
}

// A m n <d > | <d sub-array>
DM_INLINE_STATIC P petsc_mat_copyfrom(void) {
  Mat A;
  P m, n, len_arr, gm;
  L32 ncols, ncols_;
  D* a;
  D* row;

  if (o_4 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_4, A);
  if (CLASS(o_2) != NUM || CLASS(o_3) != NUM) return OPD_CLA;
  if (! PVALUE(o_2, &n) || ! PVALUE(o_3, &m)) return UNDF_VAL;
  if (TAG(o_1) != (ARRAY|DOUBLETYPE)) return OPD_ERR;

  gm = DMPETSC_MATRIX_GM(o_4);
  DMPETSC_ERRCHECK(MatGetRow(A, gm+m, &ncols, PETSC_NULL, (const D**)&row));
  if (FREEvm + sizeof(D)*ncols < CEILvm) moveD(row, (D*) FREEvm, ncols);
  DMPETSC_ERRCHECK(MatRestoreRow(A, gm+m, &ncols, PETSC_NULL, (const D**)&row));
  if (FREEvm + sizeof(L32)*ncols >= CEILvm) return VM_OVF;

  row = (D*) FREEvm;
  len_arr = ARRAY_SIZE(o_1);
  if (n < 0 || n >= ncols) return RNG_CHK;
  ncols_ = (len_arr < ncols - n) ? len_arr : ncols - n;
  a = (D*) VALUE_PTR(o_1);
  moveD(row+n, a, ncols_);

  moveframe(o_1, o_4);
  ARRAY_SIZE(o_4) = ncols_;
  FREEopds = o_3;
  return OK;
}

// A x | Ax (in x)
DM_INLINE_STATIC P petsc_mat_vecmul(void) {
  Mat A;
  Vec x;

  if (o_2 < FLOORopds) return OPDS_UNF;
  INIT_MAT(o_2, A);
  INIT_VEC(o_1, x);

  if (DMPETSC_MATRIX_M(o_2) != DMPETSC_VECTOR_N(o_1))
    RETURN_ERROR(DMPETSC_NOMATCH);

  DMPETSC_ERRCHECK(MatMult(A, x, x));

  moveframe(o_1, o_2);
  FREEopds = o_1;
  return OK;
}

typedef P (*KSPFunc)(KSP ksp, B* param);
typedef struct {
  KSPType t;
  KSPFunc f;
} KSPFlags;

static const KSPFlags ksptypes[] = {
  {KSPRICHARDSON, NULL},
  {KSPCHEBYCHEV, NULL},
  {KSPCG, NULL},
  {KSPCGNE, NULL},
  {KSPSTCG, NULL},
  {KSPGLTR, NULL},
  {KSPGMRES, NULL},
  {KSPFGMRES, NULL},
  {KSPLGMRES, NULL},
  {KSPTCQMR, NULL},
  {KSPBCGS, NULL},
  {KSPBCGSL, NULL},
  {KSPCGS, NULL},
  {KSPTFQMR, NULL},
  {KSPCR, NULL},
  {KSPLSQR, NULL},
  {KSPPREONLY, NULL},
  {KSPQCG, NULL},
  {KSPBICG, NULL},
  {KSPMINRES, NULL},
  {KSPSYMMLQ, NULL},
  {KSPLCD, NULL}
};

typedef P (*PCFunc)(PC pc, B* param);
typedef struct {
  PCType t;
  PCFunc f;
} PCFlags;

static const PCFlags pctypes[] = {
  {PCNONE, NULL},
  {PCJACOBI, NULL},
  {PCSOR, NULL},
  {PCLU, NULL},
  {PCSHELL, NULL},
  {PCBJACOBI, NULL},
  {PCMG, NULL},
  {PCEISENSTAT, NULL},
  {PCILU, NULL},
  {PCICC, NULL},
  {PCASM, NULL},
  {PCKSP, NULL},
  {PCCOMPOSITE, NULL},
  {PCREDUNDANT, NULL},
  {PCSPAI, NULL},
  {PCNN, NULL},
  {PCCHOLESKY, NULL},
  {PCSAMG, NULL},
  {PCPBJACOBI, NULL},
  {PCMAT, NULL},
  {PCHYPRE, NULL},
  {PCFIELDSPLIT, NULL},
  {PCTFS, NULL},
  {PCML, NULL},
  {PCPROMETHEUS, NULL},
  {PCGALERKIN, NULL},
  {PCOPENMP, NULL}
};
  
// ksptype ksparam pctype pcparams | KSP
DM_INLINE_STATIC P petsc_ksp_create(void) {
  PetscErrorCode r;
  P retc = 0;
  B* pframe;
  KSP* ksp = NULL;
  PC pc;
  P ksptype, pctype;
  B* oldfreevm = FREEvm;
  B* pcparam; B* kspparam;

  if (o_4 < FLOORopds) return OPDS_UNF;
  if (CLASS(o_4) != NUM) return OPD_CLA;
  PVALUE(o_4, &ksptype);
  if (ksptype < 0 || ksptype >= (P) (sizeof(ksptypes)/sizeof(ksptypes[0])))
    return RNG_CHK;
  kspparam = o_3;
  if (CLASS(o_2) != NUM) return OPD_CLA;
  PVALUE(o_2, &pctype);
  if (pctype < 0 || pctype >= (P) (sizeof(pctypes)/sizeof(pctypes[0])))
    return RNG_CHK;
  pcparam = o_1;

  MAKE_DMPETSC_KSP(pframe, 0);
  ksp = &DMPETSC_KSP_KSP(pframe);
  *ksp = NULL;
  DMPETSC_KSP_M(pframe) = 0;
  DMPETSC_KSP_KSPTYPE(pframe) = ksptype;
  DMPETSC_KSP_PCTYPE(pframe) = pctype;

  if ((r = KSPCreate(PETSC_COMM_WORLD, ksp))
      || (r = KSPSetInitialGuessNonzero(*ksp, PETSC_TRUE))
      || (ksptype != PINF && (r = KSPSetType(*ksp, ksptypes[ksptype].t)))
      || (pctype != PINF && ((r = KSPGetPC(*ksp, &pc))
			  || (r = PCSetType(pc, pctypes[pctype].t))))
      || (ksptypes[ksptype].f && (retc = ksptypes[ksptype].f(*ksp, kspparam)))
      || (pctypes[pctype].f && (retc = pctypes[pctype].f(pc, pcparam))))
    goto err;

  moveframe(pframe, o_4);
  FREEopds = o_3;
  return OK;

 err:
  if (ksp && *ksp) KSPDestroy(*ksp);
  *ksp = NULL;
  FREEvm = oldfreevm;
  if (retc) return retc;
  RETURN_ERROR(errmap[r]);
}

// ksp | --
DM_INLINE_STATIC P petsc_ksp_destroy(void) {
  KSP ksp;
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_KSP(o_1, ksp);

  DMPETSC_ERRCHECK(KSPDestroy(ksp));
  DMPETSC_KSP_KSP(o_1) = NULL;

  KILL_OPAQUE();
  return OK;
}

// ksp rtol atol dtol maxits | --
DM_INLINE_STATIC P petsc_ksp_tol(void) {
  D rtol, atol, dtol;
  LBIG maxits;
  KSP ksp;

  if (o_5 < FLOORopds) return OPDS_UNF;
  INIT_KSP(o_5, ksp);

  if (CLASS(o_1) != NUM 
      || CLASS(o_2) != NUM 
      || CLASS(o_3) != NUM 
      || CLASS(o_4) != NUM) return OPD_CLA;

  VALUE(o_1, &maxits);
  DVALUE(o_2, &dtol);
  DVALUE(o_3, &atol);
  DVALUE(o_4, &rtol);

  DMPETSC_ERRCHECK(KSPSetTolerances(ksp, 
				  ISUNDEF(rtol) ? rtol : PETSC_DEFAULT,
				  ISUNDEF(atol) ? atol : PETSC_DEFAULT,
  				  ISUNDEF(dtol) ? dtol : PETSC_DEFAULT,
				  maxits != LBIGINF ? maxits : PETSC_DEFAULT));

  FREEopds = o_5;
  return OK;
}

// KSP A/null x b | x
DM_INLINE_STATIC P petsc_ksp_solve(void) {
  KSP ksp;
  Mat A;
  Vec x;
  Vec b;
  L32* m;
  L32 n;
  KSPConvergedReason r;

  if (o_4 < FLOORopds) return OPDS_UNF;
  INIT_VEC(o_1, b);
  INIT_VEC(o_2, x);
  if (CLASS(o_3) != NULLOBJ) INIT_MAT(o_3, A);
  else A = NULL;
  INIT_KSP(o_4, ksp);

  m = &DMPETSC_KSP_M(o_4);
  if (A) *m = DMPETSC_MATRIX_M(o_3);
  else if (! *m) RETURN_ERROR(DMPETSC_KSPSOLVE_NOINIT);
  
  n = DMPETSC_VECTOR_N(o_2);
  if (*m !=  n || n != DMPETSC_VECTOR_N(o_1)) RETURN_ERROR(DMPETSC_NOMATCH);
  if (A) DMPETSC_ERRCHECK(KSPSetOperators(ksp, A, A, SAME_NONZERO_PATTERN));

  DMPETSC_ERRCHECK(KSPSetUp(ksp));
  DMPETSC_ERRCHECK(KSPSolve(ksp, b, x));
  DMPETSC_ERRCHECK(KSPGetConvergedReason(ksp, &r));
  if (r < 0) RETURN_ERROR(errmap[PETSC_ERR_MAX_VALUE + (-r)]);
    

  moveframe(o_2, o_4);
  FREEopds = o_3;
  return OK;
}

// ksp | iterations
DM_INLINE_STATIC P petsc_ksp_iterations(void) {
  KSP ksp;
  L32 its;
  if (o_1 < FLOORopds) return OPDS_UNF;
  INIT_KSP(o_1, ksp);

  if (! DMPETSC_KSP_M(o_1)) RETURN_ERROR(DMPETSC_KSPSOLVE_NOINIT);
  DMPETSC_ERRCHECK(KSPGetIterationNumber(ksp, &its));

  TAG(o_1) = (NUM|LONG32TYPE);
  ATTR(o_1) = 0;
  L32_VAL(o_1) = abs(its);

  return OK;
}

#include "dm-dmpetsc-main.h"
