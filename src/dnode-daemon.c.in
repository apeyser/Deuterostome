#line 2 "@srcdir@/dnode-daemon.c.in"

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/wait.h>
#include <signal.h>
#include <syslog.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdarg.h>
#include <string.h>

struct node {
  pid_t pid;
  int port;
  int fd;
};

struct nodes {
  int n;
  struct node node[0];
} *nodes = NULL;

#define QUIT_TIME 20
#define WAIT_TIME 20
#define CHILD_TIME 10

long renice;

#define errorxn(...) errorx(0, 0, __VA_ARGS__)
#define errorxy(...) errorx(1, 0, __VA_ARGS__)
#define warnxn(...)  errorx(0, 1, __VA_ARGS__)
#define warnxy(...)  errorx(1, 1, __VA_ARGS__)
void errorx(char doerrno, int warn, const char* format, ...);

char int_ = 0;
void sigint(int sig __attribute__((__unused__))) {int_ = 1;}
char term_ = 0;
void sigterm(int sig __attribute__((__unused__))) {term_ = 1;}
char alarm_ = 0;
void sigalarm(int sig __attribute__((__unused__))) {alarm_ = 1;}

void sethandler(void (*handler)(int), int sig, int flag) {
  struct sigaction sa;
  sigset_t mask;
  sigfillset(&mask);

  sa.sa_handler = handler;
  sa.sa_flags = flag;
  sa.sa_mask = mask;
  if (sigaction(sig, &sa, NULL) == -1)
    errorxy("Unable to setup signal handler for sig: %i", sig);
}

void lognode(struct node* node) {
  char buffer[1024];
  ssize_t s;
  while ((s = read(node->fd, buffer, sizeof(buffer)-1) > 0)) {
    buffer[s] = '\0';
    warnxn("Message from %i: %s", node->pid, buffer);
  }
  if (s < 0) {
    if (errno == EINTR) return;
    errorxy("Error reading from child %i", node->pid);
  }
}

void lognodes(int active, fd_set* read) {
  int i = 0;
  for (; active && i < nodes->n; ++i) {
    if (nodes->node[i].fd != -1 && FD_ISSET(nodes->node[i].fd, read)) {
      lognode(&nodes->node[i]);
      --active;
    }
  }
}

char killing = 0;
void killall(void) {
  int status;
  pid_t pid;
  int i;
  int n;
  
  if (! nodes) return;

  killing = 1;
  alarm_ = 0;
  sethandler(SIG_IGN, SIGINT, 0);
  sethandler(sigalarm, SIGALRM, SA_RESETHAND);
  alarm(QUIT_TIME);

  if (kill(0, SIGINT)) {
    errorxy("Error calling kill SIGINT on children");
    exit(1);
  }
  
  n = nodes->n;
  while (n && ! alarm_) {
    if ((pid = wait(&status)) < 0) {
      errorxy("Error waiting for children");
      exit(1);
    }

    for (i = 0; i < nodes->n; ++i) 
      if (nodes->node[i].pid == pid) {
	--n;
	nodes->node[i].pid = 0;
	if (! WIFEXITED(status)) {
	  errorxn("Child %i exited with status %i", pid, WEXITSTATUS(status));
	  if (WIFSIGNALED(status))
	    errorxn("Child %i exited due to signal %i", pid, WTERMSIG(status));
	}
	break;
      }
  }

  sethandler(SIG_IGN, SIGALRM, 0);
  sethandler(SIG_IGN, SIGCHLD, SA_NOCLDWAIT);

  for (i = 0; i < nodes->n; ++i)
    if (nodes->node[i].fd != -1) {
      lognode(&nodes->node[i]);
      if (close(nodes->node[i].fd))
	warnxn("Unable to close child %i pipe", nodes->node[i].pid);
    }

  if (n) {
    for (i = 0; i < nodes->n; ++i) {
      if (! nodes->node[i].pid) continue;
      if (kill(nodes->node[i].pid, SIGKILL))
	warnxy("Unable to send SIGKILL to child %i", nodes->node[i].pid);
    }
  }
  killing = 0;
  sethandler(sigint, SIGINT, 0);
}

char daemonized = 0 ;
void startlog(void) {
  daemonized = 1;
  openlog("dnode-daemon", LOG_DAEMON, LOG_CONS);
  if (close(STDIN_FILENO) 
      || close(STDOUT_FILENO) 
      || close(STDERR_FILENO))
    errorxy("Unable to close std streams");

  if (getpgrp() != getpid() && setsid() == -1) 
    errorxy("Unable to setsid");
}

void errorx(char doerrno, int warn, const char* format, ...) {
  char buffer[1024];
  va_list ap;
  va_start(ap, format);
  vsnprintf(buffer, sizeof(buffer), format, ap);
  va_end(ap);
  buffer[sizeof(buffer)-1] = '\0';

  if (daemonized) {
    int pri = warn ? LOG_WARNING : LOG_ERR;
    if (doerrno) syslog(pri, "%s: %m", buffer);
    else syslog(pri, "%s", buffer);
  }
  else {
    char* pri = warn ? "Warning" : "Error";
    if (doerrno) fprintf(stderr, "%s - %s: %s\n", pri, buffer, strerror(errno));
    else fprintf(stderr, "%s - %s\n", pri, buffer);
  }

  if (! warn) {
    if (! killing) {
      killall();
      exit(1);
    }
  }
}

void cleanupdead(fd_set* read) {
  pid_t pid;
  int i, status;

  while ((pid = waitpid(-1, &status, WNOHANG)) > 0);
  if (! pid) return;
  if (pid < 0) switch (errno) {
    case ECHILD: case EINTR: return;
    default:errorxy("Error calling waitpid");
  }

  for (i = 0; i < nodes->n; ++i)
    if (pid == nodes->node[i].pid) {
      if (! WIFEXITED(status)) {
	killing = 1;
	errorxn("Child %i exited with status %i", pid, WEXITSTATUS(status));
	if (WIFSIGNALED(status))
	  errorxn("Child %i exited due to signal %i", pid, WTERMSIG(status));
	killing = 0;
      }
      if (nodes->node[i].fd != -1) {
	lognode(&nodes->node[i]);
	if (close(nodes->node[i].fd))
	  warnxn("Unable to close read end of pipe for child %i", pid);
	FD_CLR(nodes->node[i].fd, read);
      }

      nodes->node[i].fd = -1;
      nodes->node[i].pid = 0;
    }
}

uid_t uid;
uid_t euid;
gid_t gid;
gid_t egid;

void child(int pipefd[2], int port) {
  char buffer[1024];
  if (close(pipefd[0])) {
    syslog(LOG_ERR, "Unable to close read end of pipe: %m");
    exit(1);
  }
  if (dup2(pipefd[1], STDOUT_FILENO) < 0 
      || dup2(pipefd[1], STDERR_FILENO) < 0) {
    syslog(LOG_ERR, "Unable to dup stdout and stderr to pid: %m");
    exit(1);
  }
  
  
  if (pipefd[1] != STDOUT_FILENO 
      && pipefd[1] != STDERR_FILENO
      && close(pipefd[1])) {
    fprintf(stderr, "Unable to close write end of pipe after dup\n");
    exit(1);
  }

  errno = 0;
  if (euid != 0)
    fprintf(stderr, "Not running as root - not trying to renice\n");
  else if (nice(renice) == -1 && errno) perror("Unable to renice");

  if (gid == egid)
    fprintf(stderr, "Not running setgid, not dropping privileges\n");
  else if (setegid(egid) || setgid(egid)) {
    perror("Unable to drop privileges");
    exit(1);
  }

  if (uid == euid)
    fprintf(stderr, "Not running setuid, not dropping privileges\n");
  else if (seteuid(euid) || setuid(euid)) {
    perror("Unable to drop privileges");
    exit(1);
  }
      
  sprintf(buffer, "%i", port);
  fprintf(stderr, "stderr - Starting: `%s' `%s' `%s'\n", 
	  "@bindir@/dnode", buffer, "0");
  syslog(LOG_WARNING, "syslog - Starting: `%s' `%s' `%s'\n", 
	 "@bindir@/dnode", buffer, "0");

  execl("@bindir@/dnode", "@bindir@/dnode", buffer, "0", NULL);
  perror("Unable to run `/usr/local/bin/dnode'");
  exit(1);
}

void body(fd_set* read) {
  int i;
  int pipefd[2];

  for (i=0; i<nodes->n; i++) {
    if (nodes->node[i].pid) continue;
    
    if (pipe(pipefd)) errorxy("Error creating pipe");

    switch ((nodes->node[i].pid = fork())) {
      case -1: errorxy("Unable to fork");
      case 0: child(pipefd, nodes->node[i].port);
      default:
	FD_SET(nodes->node[i].fd = pipefd[0], read);
	if (close(pipefd[1]))
	  errorxy("Unable to close write end of pipe in parent");
    }
  }
}

void mainloop(void) {
  fd_set read, read_;
  int active = 0;
  FD_ZERO(&read);

  do {
    cleanupdead(&read);
    body(&read);
    read_ = read;
    if ((active = select(nodes->n, &read_, NULL, NULL, NULL)) < 0)
      if (errno != EINTR) errorxy("Select error");
    lognodes(active, &read_);
  } while (! term_ && ! int_);

  killall();
}

const char* args(const int argc, const char* argv[]) {
  const char** argvi = argv;
  char* endptr;
  int nnodes, i;
  const char* pidfilename;

  if (argc < 4)
    errorxn("Arguments: renice-number pid-file port... - Params: %d", 
	    argc-1);
  
  renice = strtol(*++argvi, &endptr, 0);
  if (! **argvi || *endptr)
    errorxn("Renice argument must be an integer: `%s'", argvi);

  pidfilename = *++argvi;

  nnodes = argc-3;
  nodes = (struct nodes*) malloc(sizeof(struct nodes)
				  +sizeof(struct node)*nnodes);
  nodes->n = nnodes;
  for (i=0; i<nnodes; i++) {
    nodes->node[i].port = strtol(*++argvi, &endptr, 0);
    if (! **argvi || *endptr)
      errorxn("Port argument must be an integer: `%s'", *argvi);
    nodes->node[i].pid = 0;
    nodes->node[i].fd = -1;
  }

  return pidfilename;
}

void daemonize(const char* pidfilename) {
  FILE* pidfile;
  pid_t pid, pidr;
  int status;

  sethandler(sigint, SIGINT, 0);
  sethandler(sigterm, SIGTERM, 0);
  sethandler(sigterm, SIGQUIT, 0);
  
  if ((pid = fork())) {
    if (pid == -1) errorxy("Unable to fork");

    if (! (pidfile = fopen(pidfilename, "w"))) {
      kill(pid, SIGTERM);
      errorxy("Unable to open %s", pidfilename);
    }
    if (fprintf(pidfile, "%i\n", pid) < 0) {
      kill(pid, SIGTERM);
      errorxy("Unable to write to %s", pidfilename);
    }
    if (fclose(pidfile)) {
      kill(pid, SIGTERM);
      errorxy("Unable to close %s", pidfilename);
    }

    if (kill(pid, SIGINT)) errorxy("Unable to signal %i", pid);
    while ((pidr = waitpid(pid, NULL, 0)) != pid && ! int_)
      if (pidr == -1 && errno != EINTR) errorxy("Unable to wait for daemon");
      
    exit(pidr ? 1 : 0);
  }
  
  startlog();
  pause();
  if (term_) exit(0);
  if (int_) int_ = 0;
  if (kill(getppid(), SIGINT)) errorxy("Unable to signal parent");
}

void setuids(void) {
  uid = getuid();
  euid = geteuid();
  gid = getgid();
  egid = getegid();

  if (uid == euid)
    warnxn("Not running setuid, uid = %i", uid);
  else if (seteuid(uid))
    errorxy("Not able to switch euid from %i to %i", euid, uid);

  if (gid == egid)
    warnxn("Not running setgid, gid = %i", gid);
  else if (setegid(gid))
    errorxy("Not able to switch egid from %i to %i", egid, gid);
}    

int main(const int argc, const char* argv[]) {
  const char* pidfilename = args(argc, argv);
  setuids();
  daemonize(pidfilename);
  mainloop();
  
  return 0;
}
  
